diff -urEBwb /home/terminx/eduke32_src_20090131/build/include/build.h ./build/include/build.h
--- /home/terminx/eduke32_src_20090131/build/include/build.h	2009-01-31 18:56:17.800125753 -0800
+++ ./build/include/build.h	2009-03-14 07:58:47.329641485 -0700
@@ -10,6 +10,7 @@
 #define __build_h__
 
 #include "compat.h"
+#include "pragmas.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -300,6 +301,15 @@
 
 EXTERN int32_t editorzrange[2];
 
+static inline int32_t getrendermode(void)
+{
+#ifndef POLYMOST
+    return 0;
+#else
+    return rendmode;
+#endif
+}
+
 /*************************************************************************
 POSITION VARIABLES:
 
@@ -469,7 +479,26 @@
 void   getmousevalues(int32_t *mousx, int32_t *mousy, int32_t *bstatus);
 int32_t    krand(void);
 int32_t   ksqrt(int32_t num);
-int32_t   getangle(int32_t xvect, int32_t yvect);
+// int32_t   getangle(int32_t xvect, int32_t yvect);
+
+//
+// getangle
+//
+
+EXTERN int16_t radarang[1280];
+
+static inline int32_t getangle(int32_t xvect, int32_t yvect)
+{
+    if ((xvect|yvect) == 0) return(0);
+    if (xvect == 0) return(512+((yvect<0)<<10));
+    if (yvect == 0) return(((xvect<0)<<10));
+    if (xvect == yvect) return(256+((xvect<0)<<10));
+    if (xvect == -yvect) return(768+((xvect>0)<<10));
+    if (klabs(xvect) > klabs(yvect))
+        return(((radarang[640+scale(160,yvect,xvect)]>>6)+((xvect<0)<<10))&2047);
+    return(((radarang[640-scale(160,xvect,yvect)]>>6)+512+((yvect<0)<<10))&2047);
+}
+
 void   rotatepoint(int32_t xpivot, int32_t ypivot, int32_t x, int32_t y, int16_t daang, int32_t *x2, int32_t *y2);
 int32_t   lastwall(int16_t point);
 int32_t   nextsectorneighborz(int16_t sectnum, int32_t thez, int16_t topbottom, int16_t direction);
@@ -481,8 +510,33 @@
 int32_t   sectorofwall(int16_t theline);
 int32_t   loopnumofsector(int16_t sectnum, int16_t wallnum);
 
-int32_t   insertsprite(int16_t sectnum, int16_t statnum);
-int32_t   deletesprite(int16_t spritenum);
+// int32_t   insertsprite(int16_t sectnum, int16_t statnum);
+// int32_t   deletesprite(int16_t spritenum);
+
+//
+// insertsprite
+//
+
+int32_t insertspritesect(int16_t sectnum);
+int32_t insertspritestat(int16_t statnum);
+int32_t deletespritesect(int16_t deleteme);
+int32_t deletespritestat(int16_t deleteme);
+
+static inline int32_t insertsprite(int16_t sectnum, int16_t statnum)
+{
+    insertspritestat(statnum);
+    return(insertspritesect(sectnum));
+}
+
+//
+// deletesprite
+//
+static inline int32_t deletesprite(int16_t spritenum)
+{
+    deletespritestat(spritenum);
+    return(deletespritesect(spritenum));
+}
+
 int32_t   changespritesect(int16_t spritenum, int16_t newsectnum);
 int32_t   changespritestat(int16_t spritenum, int16_t newstatnum);
 int32_t   setsprite(int16_t spritenum, const vec3_t *new);
@@ -498,8 +552,6 @@
 typedef struct  s_point2d {
     float       x, y;
 }               _point2d;
-_equation       equation(float x1, float y1, float x2, float y2);
-int32_t             sameside(_equation* eq, _point2d* p1, _point2d* p2);
 int32_t             wallvisible(int16_t wallnum);
 
 #define STATUS2DSIZ 144
@@ -578,7 +630,30 @@
 int32_t Ptile2tile(int32_t tile, int32_t pallet);
 int32_t md_loadmodel(const char *fn);
 int32_t md_setmisc(int32_t modelid, float scale, int32_t shadeoff, float zadd, int32_t flags);
-int32_t md_tilehasmodel(int32_t tilenume, int32_t pal);
+// int32_t md_tilehasmodel(int32_t tilenume, int32_t pal);
+
+typedef struct
+{
+    // maps build tiles to particular animation frames of a model
+    int32_t     modelid;
+    int32_t     skinnum;
+    int32_t     framenum;   // calculate the number from the name when declaring
+    float   smoothduration;
+    int32_t     next;
+    char    pal;
+} tile2model_t;
+
+#define EXTRATILES MAXTILES
+
+EXTERN int32_t mdinited;
+EXTERN tile2model_t tile2model[MAXTILES+EXTRATILES];
+
+static inline int32_t md_tilehasmodel(int32_t tilenume,int32_t pal)
+{
+    if (!mdinited) return -1;
+    return tile2model[Ptile2tile(tilenume,pal)].modelid;
+}
+
 int32_t md_defineframe(int32_t modelid, const char *framename, int32_t tilenume, int32_t skinnum, float smoothduration, int32_t pal);
 int32_t md_defineanimation(int32_t modelid, const char *framestart, const char *frameend, int32_t fps, int32_t flags);
 int32_t md_defineskin(int32_t modelid, const char *skinfn, int32_t palnum, int32_t skinnum, int32_t surfnum, float param);
diff -urEBwb /home/terminx/eduke32_src_20090131/build/include/mdsprite.h ./build/include/mdsprite.h
--- /home/terminx/eduke32_src_20090131/build/include/mdsprite.h	2009-01-31 18:56:24.864911458 -0800
+++ ./build/include/mdsprite.h	2009-03-14 07:57:25.325644800 -0700
@@ -127,9 +127,10 @@
     md3shader_t *shaders;
     md3uv_t *uv;
     md3xyzn_t *xyzn;
+    float *geometry;
 } md3surf_t;
 
-#define SIZEOF_MD3SURF_T (sizeof(md3surf_t)-4*sizeof(void*))
+#define SIZEOF_MD3SURF_T (11*sizeof(int32_t) + 64*sizeof(char))
 
 typedef struct
 {
@@ -200,6 +201,7 @@
     int32_t is8bit;
 } voxmodel_t;
 
+/*
 typedef struct
 {
     // maps build tiles to particular animation frames of a model
@@ -213,6 +215,8 @@
 
 #define EXTRATILES MAXTILES
 EXTERN tile2model_t tile2model[MAXTILES+EXTRATILES];
+*/
+
 EXTERN mdmodel_t **models;
 
 void updateanimation(md2model_t *m, spritetype *tspr);
@@ -226,7 +230,6 @@
 
 EXTERN hudtyp hudmem[2][MAXTILES]; //~320KB ... ok for now ... could replace with dynamic alloc
 
-EXTERN int32_t mdinited;
 EXTERN int32_t mdpause;
 EXTERN int32_t nummodelsalloced, nextmodelid;
 EXTERN voxmodel_t *voxmodels[MAXVOXELS];
diff -urEBwb /home/terminx/eduke32_src_20090131/build/Makefile.shared ./build/Makefile.shared
--- /home/terminx/eduke32_src_20090131/build/Makefile.shared	2009-01-31 18:53:50.421780034 -0800
+++ ./build/Makefile.shared	2009-03-14 07:57:25.327646181 -0700
@@ -3,8 +3,8 @@
 ENGINELIB=libengine.a
 EDITORLIB=libbuild.a
 
-SDLCONFIG	= /usr/local/bin/sdl-config
-# SDLCONFIG = sdl-config
+# SDLCONFIG	= /usr/local/bin/sdl-config
+SDLCONFIG = sdl-config
 
 ifeq ($(wildcard $(SDLCONFIG)),$(SDLCONFIG))
     SDLROOT		= /usr/local
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/engine.c ./build/src/engine.c
--- /home/terminx/eduke32_src_20090131/build/src/engine.c	2009-01-31 18:56:30.502777524 -0800
+++ ./build/src/engine.c	2009-03-14 07:59:25.981641867 -0700
@@ -99,7 +99,7 @@
 
 int32_t artsize = 0, cachesize = 0;
 
-static int16_t radarang[1280], radarang2[MAXXDIM];
+static int16_t radarang2[MAXXDIM];
 static uint16_t sqrtable[4096], shlookup[4096+256];
 char pow2char[8] = {1,2,4,8,16,32,64,128};
 int32_t pow2long[32] =
@@ -993,7 +993,7 @@
 //
 // spritewallfront (internal)
 //
-static int32_t spritewallfront(spritetype *s, int32_t w)
+static inline int32_t spritewallfront(spritetype *s, int32_t w)
 {
     walltype *wal;
     int32_t x1, y1;
@@ -1058,7 +1058,7 @@
 //
 // bunchfront (internal)
 //
-static int32_t bunchfront(int32_t b1, int32_t b2)
+static inline int32_t bunchfront(int32_t b1, int32_t b2)
 {
     int32_t x1b1, x2b1, x1b2, x2b2, b1f, b2f, i;
 
@@ -1080,7 +1080,7 @@
 //
 // hline (internal)
 //
-static void hline(int32_t xr, int32_t yp)
+static inline void hline(int32_t xr, int32_t yp)
 {
     int32_t xl, r, s;
 
@@ -1098,7 +1098,7 @@
 //
 // slowhline (internal)
 //
-static void slowhline(int32_t xr, int32_t yp)
+static inline void slowhline(int32_t xr, int32_t yp)
 {
     int32_t xl, r;
 
@@ -1203,7 +1203,7 @@
 //
 // animateoffs (internal)
 //
-int32_t animateoffs(int16_t tilenum, int16_t fakevar)
+inline int32_t animateoffs(int16_t tilenum, int16_t fakevar)
 {
     int32_t i, k, offs;
 
@@ -2081,7 +2081,7 @@
 //
 // transmaskwallscan (internal)
 //
-static void transmaskwallscan(int32_t x1, int32_t x2)
+static inline void transmaskwallscan(int32_t x1, int32_t x2)
 {
     int32_t x;
 
@@ -2106,7 +2106,7 @@
 //
 // ceilspritehline (internal)
 //
-static void ceilspritehline(int32_t x2, int32_t y)
+static inline void ceilspritehline(int32_t x2, int32_t y)
 {
     int32_t x1, v, bx, by;
 
@@ -2136,7 +2136,7 @@
 //
 // ceilspritescan (internal)
 //
-static void ceilspritescan(int32_t x1, int32_t x2)
+static inline void ceilspritescan(int32_t x1, int32_t x2)
 {
     int32_t x, y1, y2, twall, bwall;
 
@@ -5010,7 +5010,7 @@
 //
 // initksqrt (internal)
 //
-static void initksqrt(void)
+static inline void initksqrt(void)
 {
     int32_t i, j, k;
 
@@ -5068,7 +5068,7 @@
 //
 // loadtables (internal)
 //
-static void calcbritable(void)
+static inline void calcbritable(void)
 {
     int32_t i,j;
     double a,b;
@@ -5245,7 +5245,7 @@
 //
 // insertspritesect (internal)
 //
-static int32_t insertspritesect(int16_t sectnum)
+int32_t insertspritesect(int16_t sectnum)
 {
     int16_t blanktouse;
 
@@ -5273,7 +5273,7 @@
 //
 // insertspritestat (internal)
 //
-static int32_t insertspritestat(int16_t statnum)
+int32_t insertspritestat(int16_t statnum)
 {
     int16_t blanktouse;
 
@@ -5301,7 +5301,7 @@
 //
 // deletespritesect (internal)
 //
-static int32_t deletespritesect(int16_t deleteme)
+int32_t deletespritesect(int16_t deleteme)
 {
     if (sprite[deleteme].sectnum == MAXSECTORS)
         return(-1);
@@ -5325,7 +5325,7 @@
 //
 // deletespritestat (internal)
 //
-static int32_t deletespritestat(int16_t deleteme)
+int32_t deletespritestat(int16_t deleteme)
 {
     if (sprite[deleteme].statnum == MAXSTATUS)
         return(-1);
@@ -5349,7 +5349,7 @@
 //
 // lintersect (internal)
 //
-static int32_t lintersect(int32_t x1, int32_t y1, int32_t z1, int32_t x2, int32_t y2, int32_t z2, int32_t x3,
+static inline int32_t lintersect(int32_t x1, int32_t y1, int32_t z1, int32_t x2, int32_t y2, int32_t z2, int32_t x3,
                       int32_t y3, int32_t x4, int32_t y4, int32_t *intx, int32_t *inty, int32_t *intz)
 {
     //p1 to p2 is a line segment
@@ -5382,7 +5382,7 @@
 //
 // rintersect (internal)
 //
-static int32_t rintersect(int32_t x1, int32_t y1, int32_t z1, int32_t vx, int32_t vy, int32_t vz, int32_t x3,
+static inline int32_t rintersect(int32_t x1, int32_t y1, int32_t z1, int32_t vx, int32_t vy, int32_t vz, int32_t x3,
                       int32_t y3, int32_t x4, int32_t y4, int32_t *intx, int32_t *inty, int32_t *intz)
 {
     //p1 towards p2 is a ray
@@ -5414,7 +5414,7 @@
 //
 // keepaway (internal)
 //
-static void keepaway(int32_t *x, int32_t *y, int32_t w)
+static inline void keepaway(int32_t *x, int32_t *y, int32_t w)
 {
     int32_t dx, dy, ox, oy, x1, y1;
     char first;
@@ -5435,7 +5435,7 @@
 //
 // raytrace (internal)
 //
-static int32_t raytrace(int32_t x3, int32_t y3, int32_t *x4, int32_t *y4)
+static inline int32_t raytrace(int32_t x3, int32_t y3, int32_t *x4, int32_t *y4)
 {
     int32_t x1, y1, x2, y2, bot, topu, nintx, ninty, cnt, z, hitwall;
     int32_t x21, y21, x43, y43;
@@ -5894,19 +5894,19 @@
 }
 
 // UTILITY TYPES AND FUNCTIONS FOR DRAWMASKS OCCLUSION TREE
-typedef struct          s_maskleaf
-{
-    int32_t                index;
-    _point2d            p1, p2;
-    _equation           maskeq, p1eq, p2eq;
-    struct s_maskleaf*  branch[MAXWALLSB];
-    int32_t                 drawing;
-}                       _maskleaf;
-
-_maskleaf               maskleaves[MAXWALLSB];
+// typedef struct          s_maskleaf
+// {
+//     int32_t                index;
+//     _point2d            p1, p2;
+//     _equation           maskeq, p1eq, p2eq;
+//     struct s_maskleaf*  branch[MAXWALLSB];
+//     int32_t                 drawing;
+// }                       _maskleaf;
+// 
+// _maskleaf               maskleaves[MAXWALLSB];
 
 // returns equation of a line given two points
-_equation       equation(float x1, float y1, float x2, float y2)
+static inline _equation       equation(float x1, float y1, float x2, float y2)
 {
     _equation   ret;
 
@@ -5946,7 +5946,7 @@
     else
         return (0);
 }
-
+/*
 // returns the intersection point between two lines
 _point2d        intersection(_equation eq1, _equation eq2)
 {
@@ -5993,7 +5993,7 @@
 }
 
 // recursive mask drawing function
-void    drawmaskleaf(_maskleaf* wall)
+static inline void    drawmaskleaf(_maskleaf* wall)
 {
     int32_t i;
 
@@ -6012,8 +6012,9 @@
     //OSD_Printf("Drawing mask %i\n", wall->index);
     drawmaskwall(wall->index);
 }
+*/
 
-int32_t         sameside(_equation* eq, _point2d* p1, _point2d* p2)
+static inline int32_t         sameside(_equation* eq, _point2d* p1, _point2d* p2)
 {
     float   sign1, sign2;
 
@@ -7054,7 +7055,7 @@
 }
 
 // Powerslave uses v6
-// Witchaven 1 and TekWar use v5
+// Witchaven 1 and TekWar and LameDuke use v5
 int32_t loadoldboard(char *filename, char fromwhere, int32_t *daposx, int32_t *daposy, int32_t *daposz,
                  int16_t *daang, int16_t *dacursectnum)
 {
@@ -8165,22 +8166,6 @@
 
 
 //
-// getangle
-//
-int32_t getangle(int32_t xvect, int32_t yvect)
-{
-    if ((xvect|yvect) == 0) return(0);
-    if (xvect == 0) return(512+((yvect<0)<<10));
-    if (yvect == 0) return(((xvect<0)<<10));
-    if (xvect == yvect) return(256+((xvect<0)<<10));
-    if (xvect == -yvect) return(768+((xvect>0)<<10));
-    if (klabs(xvect) > klabs(yvect))
-        return(((radarang[640+scale(160,yvect,xvect)]>>6)+((xvect<0)<<10))&2047);
-    return(((radarang[640-scale(160,xvect,yvect)]>>6)+512+((yvect<0)<<10))&2047);
-}
-
-
-//
 // ksqrt
 //
 int32_t ksqrt(int32_t num)
@@ -8235,26 +8220,6 @@
 }
 
 //
-// insertsprite
-//
-int32_t insertsprite(int16_t sectnum, int16_t statnum)
-{
-    insertspritestat(statnum);
-    return(insertspritesect(sectnum));
-}
-
-
-//
-// deletesprite
-//
-int32_t deletesprite(int16_t spritenum)
-{
-    deletespritestat(spritenum);
-    return(deletespritesect(spritenum));
-}
-
-
-//
 // changespritesect
 //
 int32_t changespritesect(int16_t spritenum, int16_t newsectnum)
@@ -11955,19 +11920,6 @@
 }
 
 //
-// getrendermode
-//
-int32_t getrendermode(void)
-{
-#ifndef POLYMOST
-    return 0;
-#else
-    return rendmode;
-#endif
-}
-
-
-//
 // setrollangle
 //
 #ifdef POLYMOST
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/hightile.c ./build/src/hightile.c
--- /home/terminx/eduke32_src_20090131/build/src/hightile.c	2009-01-09 01:29:17.505954000 -0800
+++ ./build/src/hightile.c	2009-02-27 23:44:54.535084000 -0800
@@ -285,6 +285,8 @@
 
 #else /* POLYMOST */
 
+#include "inttypes.h"
+
 void hicsetpalettetint(int32_t palnum, char r, char g, char b, char effect) { }
 int32_t hicsetsubsttex(int32_t picnum, int32_t palnum, char *filen, float alphacut) { return 0; }
 int32_t hicsetskybox(int32_t picnum, int32_t palnum, char *faces[6]) { return 0; }
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/mdsprite.c ./build/src/mdsprite.c
--- /home/terminx/eduke32_src_20090131/build/src/mdsprite.c	2009-01-31 02:41:21.884769000 -0800
+++ ./build/src/mdsprite.c	2009-03-13 19:55:39.565179000 -0700
@@ -15,6 +15,8 @@
 #include "kplib.h"
 #include "md4.h"
 
+#include <math.h>
+
 voxmodel_t *voxmodels[MAXVOXELS];
 int32_t curextra=MAXTILES;
 
@@ -214,11 +216,13 @@
     return 0;
 }
 
+/*
 int32_t md_tilehasmodel(int32_t tilenume,int32_t pal)
 {
     if (!mdinited) return -1;
     return tile2model[Ptile2tile(tilenume,pal)].modelid;
 }
+*/
 
 static int32_t framename2index(mdmodel_t *vm, const char *nam)
 {
@@ -424,8 +428,7 @@
             palconv[i].pal1=pal1;
             palconv[i].pal2=pal2;return;
         }
-        else
-            if (palconv[i].pal==pal&&palconv[i].pal1==pal1)
+        else if (palconv[i].pal==pal&&palconv[i].pal1==pal1)
             {
                 palconv[i].pal2=pal2;return;
             }
@@ -1533,6 +1536,129 @@
     return(m);
 }
 
+static void     md3postload(md3model_t* m)
+{
+    int         framei, surfi, verti;
+    md3xyzn_t   *frameverts;
+    float       dist, lat, lng, vec[3];
+
+    // apparently we can't trust loaded models bounding box/sphere information,
+    // so let's compute it ourselves
+
+    framei = 0;
+
+    while (framei < m->head.numframes)
+    {
+        m->head.frames[framei].min.x    = 0.0f;
+        m->head.frames[framei].min.y    = 0.0f;
+        m->head.frames[framei].min.z    = 0.0f;
+
+        m->head.frames[framei].max.x    = 0.0f;
+        m->head.frames[framei].max.y    = 0.0f;
+        m->head.frames[framei].max.z    = 0.0f;
+
+        m->head.frames[framei].r        = 0.0f;
+
+        surfi = 0;
+        while (surfi < m->head.numsurfs)
+        {
+            frameverts = &m->head.surfs[surfi].xyzn[framei * m->head.surfs[surfi].numverts];
+
+            verti = 0;
+            while (verti < m->head.surfs[surfi].numverts)
+            {
+                if (!verti && !surfi)
+                {
+                    m->head.frames[framei].min.x    = frameverts[verti].x;
+                    m->head.frames[framei].min.y    = frameverts[verti].y;
+                    m->head.frames[framei].min.z    = frameverts[verti].z;
+
+                    m->head.frames[framei].max.x    = frameverts[verti].x;
+                    m->head.frames[framei].max.y    = frameverts[verti].y;
+                    m->head.frames[framei].max.z    = frameverts[verti].z;
+                } else {
+                    if (m->head.frames[framei].min.x > frameverts[verti].x)
+                        m->head.frames[framei].min.x = frameverts[verti].x;
+                    if (m->head.frames[framei].max.x < frameverts[verti].x)
+                        m->head.frames[framei].max.x = frameverts[verti].x;
+
+                    if (m->head.frames[framei].min.y > frameverts[verti].y)
+                        m->head.frames[framei].min.y = frameverts[verti].y;
+                    if (m->head.frames[framei].max.y < frameverts[verti].y)
+                        m->head.frames[framei].max.y = frameverts[verti].y;
+
+                    if (m->head.frames[framei].min.z > frameverts[verti].z)
+                        m->head.frames[framei].min.z = frameverts[verti].z;
+                    if (m->head.frames[framei].max.z < frameverts[verti].z)
+                        m->head.frames[framei].max.z = frameverts[verti].z;
+                }
+
+                verti++;
+            }
+            surfi++;
+        }
+
+        m->head.frames[framei].cen.x = (m->head.frames[framei].min.x + m->head.frames[framei].max.x) / 2.0f;
+        m->head.frames[framei].cen.y = (m->head.frames[framei].min.y + m->head.frames[framei].max.y) / 2.0f;
+        m->head.frames[framei].cen.z = (m->head.frames[framei].min.z + m->head.frames[framei].max.z) / 2.0f;
+
+        surfi = 0;
+        while (surfi < m->head.numsurfs)
+        {
+            frameverts = &m->head.surfs[surfi].xyzn[framei * m->head.surfs[surfi].numverts];
+
+            verti = 0;
+            while (verti < m->head.surfs[surfi].numverts)
+            {
+                vec[0] = frameverts[verti].x - m->head.frames[framei].cen.x;
+                vec[1] = frameverts[verti].y - m->head.frames[framei].cen.y;
+                vec[2] = frameverts[verti].z - m->head.frames[framei].cen.z;
+
+                dist = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];
+
+                if (dist > m->head.frames[framei].r)
+                    m->head.frames[framei].r = dist;
+
+                verti++;
+            }
+            surfi++;
+        }
+
+        m->head.frames[framei].r = sqrt(m->head.frames[framei].r);
+
+        framei++;
+    }
+
+    // let's also repack the geometry to more usable formats
+
+    surfi = 0;
+    while (surfi < m->head.numsurfs)
+    {
+        m->head.surfs[surfi].geometry = malloc(m->head.numframes * m->head.surfs[surfi].numverts * sizeof(float) * 6);
+
+        verti = 0;
+        while (verti < (m->head.numframes * m->head.surfs[surfi].numverts))
+        {
+            m->head.surfs[surfi].geometry[(verti * 6) + 0] = m->head.surfs[surfi].xyzn[verti].x;
+            m->head.surfs[surfi].geometry[(verti * 6) + 1] = m->head.surfs[surfi].xyzn[verti].y;
+            m->head.surfs[surfi].geometry[(verti * 6) + 2] = m->head.surfs[surfi].xyzn[verti].z;
+
+            // normal extraction from packed spherical coordinates
+            // FIXME: swapping lat and lng because of npherno's compiler
+            lat = m->head.surfs[surfi].xyzn[verti].nlng * (2 * PI) / 255.0f;
+            lng = m->head.surfs[surfi].xyzn[verti].nlat * (2 * PI) / 255.0f;
+
+            m->head.surfs[surfi].geometry[(verti * 6) + 3] = cos(lat) * sin(lng);
+            m->head.surfs[surfi].geometry[(verti * 6) + 4] = sin(lat) * sin(lng);
+            m->head.surfs[surfi].geometry[(verti * 6) + 5] = cos(lng);
+
+            verti++;
+        }
+        surfi++;
+    }
+
+}
+
 static int32_t md3draw(md3model_t *m, spritetype *tspr)
 {
     point3d fp, fp1, fp2, m0, m1, a0;
@@ -2949,9 +3075,13 @@
     {
     case 0x32504449:
 //        initprintf("Warning: model '%s' is version IDP2; wanted version IDP3\n",filnam);
-        vm = (mdmodel_t*)md2load(fil,filnam); break; //IDP2
+        vm = (mdmodel_t*)md2load(fil,filnam);
+        md3postload((md3model_t*)vm);
+        break; //IDP2
     case 0x33504449:
-        vm = (mdmodel_t*)md3load(fil); break; //IDP3
+        vm = (mdmodel_t*)md3load(fil);
+        md3postload((md3model_t*)vm);
+        break; //IDP3
     default:
         vm = (mdmodel_t*)0; break;
     }
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/mmulti.c ./build/src/mmulti.c
--- /home/terminx/eduke32_src_20090131/build/src/mmulti.c	2009-01-09 23:38:50.929875000 -0800
+++ ./build/src/mmulti.c	2009-02-19 08:47:54.128197000 -0800
@@ -99,8 +99,7 @@
 {
     if (!natfree || nfFinished)
         return 1;
-    else
-        if (nfCurrentPlayer == other) return 1;
+    else if (nfCurrentPlayer == other) return 1;
 
     return 0;
 }
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/mmulti_unstable.c ./build/src/mmulti_unstable.c
--- /home/terminx/eduke32_src_20090131/build/src/mmulti_unstable.c	2009-01-31 01:15:25.420778000 -0800
+++ ./build/src/mmulti_unstable.c	2009-03-13 19:55:39.565179000 -0700
@@ -205,7 +205,7 @@
 
     if (!argc)
     {
-//        initprintf("mmulti_unstable: No configuration file specified!\n");
+//        initprintf("network: No configuration file specified!\n");
         numplayers = 1; myconnectindex = 0;
         connecthead = 0; connectpoint2[0] = -1;
         return;
@@ -954,13 +954,13 @@
     if (natfree)
     {
         //initprintf("Stun is currently %s\n", (natfree) ? "Enabled":"Disabled");
-        initprintf("mmulti_unstable: Stun enabled\n");
+        initprintf("network: Stun enabled\n");
     }
 
     udpsocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
     if ((signed)udpsocket == -1)
     {
-        initprintf("mmulti_unstable: socket creation failed: %s\n", netstrerror());
+        initprintf("network: socket creation failed: %s\n", netstrerror());
         return(0);
     }
 
@@ -981,7 +981,7 @@
     addr.sin_port = htons((uint16_t)port);
     if (bind(udpsocket, (struct sockaddr *) &addr, sizeof(addr)) == -1)
     {
-        initprintf("mmulti_unstable: socket binding failed: %s\n", netstrerror());
+        initprintf("network: socket binding failed: %s\n", netstrerror());
         return(0);
     }
 
@@ -1049,12 +1049,12 @@
 
             if (rc != sizeof(packet))
             {
-                initprintf("mmulti_unstable: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
                 continue;
             }
             else if (packet.header != HEADER_PEER_GREETING)
             {
-                initprintf("mmulti_unstable: Unexpected packet type from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Unexpected packet type from %s:%i ?!\n", ipstr, port);
                 continue;
             }
 
@@ -1065,7 +1065,7 @@
             }
 
             if (i == max)
-                initprintf("mmulti_unstable: Disallowed player %s:%d ?!\n", ipstr, port);
+                initprintf("network: Disallowed player %s:%d ?!\n", ipstr, port);
             else if (heard_from[i] == 0)
             {
                 packet.id = B_SWAP16(packet.id);
@@ -1090,7 +1090,7 @@
 
     if (quitevent)
     {
-        initprintf("Connection attempt aborted.\n");
+        initprintf("network: Connection attempt aborted.\n");
         return(0);
     }
 
@@ -1129,8 +1129,8 @@
         {
             if (heard_from[i] == heard_from[i+1])  /* blah. */
             {
-                initprintf("mmulti_unstable: ERROR: Two players have the same random ID!\n");
-                initprintf("mmulti_unstable: ERROR: Please restart the game to generate new IDs.\n");
+                initprintf("network: ERROR: Two players have the same random ID!\n");
+                initprintf("network: ERROR: Please restart the game to generate new IDs.\n");
                 return(0);
             }
 
@@ -1179,11 +1179,11 @@
                 gcom->myconnectindex = i;
         }
 
-        initprintf("mmulti_unstable: player #%i at %s:%i\n", i,static_ipstring(ip),allowed_addresses[i].port);
+        initprintf("network: player #%i at %s:%i\n", i,static_ipstring(ip),allowed_addresses[i].port);
     }
 //    assert(gcom->myconnectindex);
 
-    initprintf("mmulti_unstable: We are player #%i\n", gcom->myconnectindex);
+    initprintf("network: We are player #%i\n", gcom->myconnectindex);
 
     return(1);
 }
@@ -1215,12 +1215,12 @@
         my_id = (uint16_t) rand();
     }
 
-    initprintf("mmulti_unstable: Using 0x%X as client ID\n", my_id);
+    initprintf("network: Using 0x%X as client ID\n", my_id);
 
     resendat = getticks();
     remaining = max = gcom->numplayers - 1;
 
-    initprintf("Waiting for %d player%s...\n", remaining, remaining==1 ? "":"s");
+    initprintf("network: Waiting for %d player%s...\n", remaining, remaining==1 ? "":"s");
     if (remaining == 0)
     {
         initprintf("Hmmm... don't have time to play with myself!\n");
@@ -1240,7 +1240,7 @@
                 //this is where special formatting of allow lines comes in
                 if (!heard_from[i])
                 {
-                    initprintf("%s %s:%d...\n",first_send?"Connecting to":"Retrying",
+                    initprintf("network: %s %s:%d...\n",first_send?"Connecting to":"Retrying",
                                static_ipstring(allowed_addresses[i].host),allowed_addresses[i].port);
 
                     send_peer_greeting(allowed_addresses[i].host,
@@ -1265,12 +1265,12 @@
 
             if (rc != sizeof(packet))
             {
-                initprintf("mmulti_unstable: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
                 continue;
             }
             else if (packet.header != HEADER_PEER_GREETING)
             {
-                initprintf("mmulti_unstable: Unexpected packet type from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Unexpected packet type from %s:%i ?!\n", ipstr, port);
                 continue;
             }
 
@@ -1289,9 +1289,9 @@
                 packet.id = B_SWAP16(packet.id);
                 heard_from[i] = packet.id;
 
-                initprintf("Connected to %s:%i\n",
+                initprintf("network: Connected to %s:%i\n",
                            ipstr, (unsigned)port);
-                initprintf("Waiting for server to launch game\n");
+                initprintf("network: Waiting for server to launch game\n");
             }
             else
             {
@@ -1300,7 +1300,7 @@
                     packet.id = B_SWAP16(packet.id);
                     heard_from[i] = packet.id;
 
-                    initprintf("New player with id 0x%X\n",
+                    initprintf("network: New player with id 0x%X\n",
                         (int32_t) packet.id);
                     gcom->numplayers++;
                     max++;
@@ -1311,7 +1311,7 @@
 
     if (quitevent)
     {
-        initprintf("Connection attempt aborted.\n");
+        initprintf("network: Connection attempt aborted.\n");
         return(0);
     }
 
@@ -1328,8 +1328,8 @@
         {
             if (heard_from[i] == heard_from[i+1])  /* blah. */
             {
-                initprintf("mmulti_unstable: ERROR: Two players have the same random ID!\n");
-                initprintf("mmulti_unstable: ERROR: Please restart the game to generate new IDs.\n");
+                initprintf("network: ERROR: Two players have the same random ID!\n");
+                initprintf("network: ERROR: Please restart the game to generate new IDs.\n");
                 return(0);
             }
 
@@ -1377,11 +1377,11 @@
                 gcom->myconnectindex = i;
         }
 
-//        initprintf("mmulti_unstable: player #%i with id %d\n",i,heard_from[i]);
+//        initprintf("network: player #%i with id %d\n",i,heard_from[i]);
     }
 //    assert(gcom->myconnectindex);
 
-//    initprintf("mmulti_unstable: We are player #%i\n", gcom->myconnectindex);
+//    initprintf("network: We are player #%i\n", gcom->myconnectindex);
 
     return(1);
 }
@@ -1406,7 +1406,7 @@
     {
         if (gcom->numplayers > 1)
         {
-            initprintf("mmulti_unstable: Error: can't do both 'broadcast' and 'allow'.\n");
+            initprintf("network: Error: can't do both 'broadcast' and 'allow'.\n");
             return(0);
         }
 
@@ -1427,7 +1427,7 @@
     }
 
 
-    initprintf("mmulti_unstable: Using 0x%X as client ID\n", my_id);
+    initprintf("network: Using 0x%X as client ID\n", my_id);
 
     resendat = getticks();
     remaining = max = gcom->numplayers - 1;
@@ -1465,7 +1465,7 @@
 
                     if (!heard_from[i])
                     {
-                        initprintf("%s %s:%d...\n",first_send?"Connecting to":"Retrying",
+                        initprintf("network: %s %s:%d...\n",first_send?"Connecting to":"Retrying",
                                    static_ipstring(allowed_addresses[i].host),allowed_addresses[i].port);
 
                         send_peer_greeting(allowed_addresses[i].host,
@@ -1526,7 +1526,7 @@
                         {
                             if (allowed_addresses[i].port != port)
                             {
-                                initprintf("mmulti_unstable: Port number for player %d changed from %d to %d.\n",i,allowed_addresses[i].port,port);
+                                initprintf("network: Port number for player %d changed from %d to %d.\n",i,allowed_addresses[i].port,port);
                                 /*                                initprintf("Different player Port Number detected. %s:%i\n",ipstr,
                                                                            allowed_addresses[i].port);
                                                                 initprintf("Changed to %s:%i, player may be behind a firewall.\n", ipstr, port); //addfaz NAT addition */
@@ -1549,13 +1549,13 @@
             }
 
             if (i == max)
-                initprintf("mmulti_unstable: Disallowed player %s:%d ?!\n", ipstr, port);
+                initprintf("network: Disallowed player %s:%d ?!\n", ipstr, port);
 
             else if (rc != sizeof(packet))
-                initprintf("mmulti_unstable: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Missized packet or fragment from %s:%i ?!\n", ipstr, port);
 
             else if (packet.header != HEADER_PEER_GREETING)
-                initprintf("mmulti_unstable: Unexpected packet type from %s:%i ?!\n", ipstr, port);
+                initprintf("network: Unexpected packet type from %s:%i ?!\n", ipstr, port);
 
             else if (heard_from[i] == 0)
             {
@@ -1565,7 +1565,7 @@
                 allowed_addresses[i].port = port;
                 remaining--;
 
-                initprintf("Connected to %s:%i (id 0x%X). %d player%s left.\n",
+                initprintf("network: Connected to %s:%i (id 0x%X). %d player%s left.\n",
                            ipstr, port ,(int32_t) packet.id,
                            remaining, remaining == 1 ? "" : "s");
 
@@ -1589,7 +1589,7 @@
 
     if (quitevent)
     {
-        initprintf("Connection attempt aborted.\n");
+        initprintf("network: Connection attempt aborted.\n");
         return(0);
     }
 
@@ -1606,8 +1606,8 @@
         {
             if (heard_from[i] == heard_from[i+1])  /* blah. */
             {
-                initprintf("mmulti_unstable: ERROR: Two players have the same random ID!\n");
-                initprintf("mmulti_unstable: ERROR: Please restart the game to generate new IDs.\n");
+                initprintf("network: ERROR: Two players have the same random ID!\n");
+                initprintf("network: ERROR: Please restart the game to generate new IDs.\n");
                 return(0);
             }
 
@@ -1656,11 +1656,11 @@
                 gcom->myconnectindex = i;
         }
 
-        initprintf("mmulti_unstable: player #%i at %s:%i\n", i,static_ipstring(ip),allowed_addresses[i].port);
+        initprintf("network: player #%i at %s:%i\n", i,static_ipstring(ip),allowed_addresses[i].port);
     }
 //    assert(gcom->myconnectindex);
 
-    initprintf("mmulti_unstable: We are player #%i\n", gcom->myconnectindex);
+    initprintf("network: We are player #%i\n", gcom->myconnectindex);
 
     /*
      * Ok, we should have specific IPs and ports for all players, and
@@ -1811,7 +1811,7 @@
                 j = strtol(argv[i]+2, &p, 10);
                 if (!(*p) && j > 1024 && j<65535) udpport = j;
 
-                initprintf("mmulti_unstable: Using port %d\n", udpport);
+                initprintf("network: Using port %d\n", udpport);
             }
         }
 
@@ -1831,9 +1831,9 @@
                             udpmode = udpmode_server;
                             gcom->numplayers = (argv[i][4]-'0');
                             if ((argv[i][5] >= '0') && (argv[i][5] <= '9')) gcom->numplayers = gcom->numplayers*10+(argv[i][5]-'0');
-                            initprintf("mmulti_unstable: %d-player game server\n", gcom->numplayers--);
+                            initprintf("network: %d-player game server\n", gcom->numplayers--);
                         }
-                        initprintf("mmulti_unstable: Master-slave mode\n");
+                        initprintf("network: Master-slave mode\n");
                     }
                     else if (argv[i][2] == '1')
                     {
@@ -1841,7 +1841,7 @@
                         udpmode = udpmode_peer;
                         myconnectindex = daindex;
 //                        daindex++;
-                        initprintf("mmulti_unstable: Peer-to-peer mode\n");
+                        initprintf("network: Peer-to-peer mode\n");
                     }
                     continue;
                 }
@@ -1854,7 +1854,7 @@
             {
 //                if ((danetmode == 1) && (daindex == myconnectindex)) daindex++;
                 parse_interface(st, &allowed_addresses[daindex].host, &allowed_addresses[daindex].port);
-                initprintf("mmulti_unstable: Player %d at %s:%d\n",daindex,st,allowed_addresses[daindex].port);
+                initprintf("network: Player %d at %s:%d\n",daindex,st,allowed_addresses[daindex].port);
                 daindex++;
             }
             else
@@ -1870,11 +1870,11 @@
 //                        if ((danetmode == 1) && (daindex == myconnectindex)) daindex++;
                     allowed_addresses[daindex].host = ntohl(*(int32_t *)lph->h_addr);
                     allowed_addresses[daindex].port = pt;
-                    initprintf("mmulti_unstable: Player %d at %s:%d (%s)\n",daindex,
+                    initprintf("network: Player %d at %s:%d (%s)\n",daindex,
                                inet_ntoa(*(struct in_addr *)lph->h_addr),pt,argv[i]);
                     daindex++;
                 }
-                else initprintf("mmulti_unstable: Failed resolving %s\n",argv[i]);
+                else initprintf("network: Failed resolving %s\n",argv[i]);
             }
             free(st);
         }
@@ -1884,7 +1884,7 @@
     }
     else
     {
-        initprintf("mmulti_unstable: Using '%s' as configuration file\n", argv[0]);
+        initprintf("network: Using '%s' as configuration file\n", argv[0]);
 
         ptr = buf;
         while ((tok = get_token(&ptr)) != NULL)
@@ -1898,7 +1898,7 @@
                 {
                     bogus = 0;
                 }
-                initprintf("mmulti_unstable: Using interface %s:%d\n",
+                initprintf("network: Using interface %s:%d\n",
                            static_ipstring(ip), (int32_t) udpport);
             }
 
@@ -2051,7 +2051,7 @@
 
     deinitialize_sockets();
 
-    initprintf("UDP net deinitialized successfully.\n");
+    initprintf("UDP networking uninitialized successfully.\n");
 }
 
 
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/polymost.c ./build/src/polymost.c
--- /home/terminx/eduke32_src_20090131/build/src/polymost.c	2009-01-31 02:40:43.532778000 -0800
+++ ./build/src/polymost.c	2009-02-27 23:44:54.535084000 -0800
@@ -2151,7 +2151,7 @@
                 hicfindsubst(globalpicnum, DETAILPAL, 0))
             detailpth = gltexcache(globalpicnum, DETAILPAL, method&(~3));
 
-        if (detailpth && (detailpth->hicr->palnum == DETAILPAL))
+        if (detailpth && detailpth->hicr && (detailpth->hicr->palnum == DETAILPAL))
         {
             bglActiveTextureARB(++texunits);
 
@@ -2197,7 +2197,7 @@
                 hicfindsubst(globalpicnum, GLOWPAL, 0))
             glowpth = gltexcache(globalpicnum, GLOWPAL, method&(~3));
 
-        if (glowpth && (glowpth->hicr->palnum == GLOWPAL))
+        if (glowpth && glowpth->hicr && (glowpth->hicr->palnum == GLOWPAL))
         {
             bglActiveTextureARB(++texunits);
 
@@ -4488,9 +4488,7 @@
         hitallsprites = 0;
 
         searchsector = hitinfo.hitsect;
-        if (hitinfo.pos.z<cz) searchstat = 1;else
-        if (hitinfo.pos.z>fz) searchstat = 2;else
-        if (hitinfo.hitwall >= 0)
+        if (hitinfo.pos.z<cz) searchstat = 1; else if (hitinfo.pos.z>fz) searchstat = 2; else if (hitinfo.hitwall >= 0)
         {
             searchwall = hitinfo.hitwall; searchstat = 0;
             if (wall[hitinfo.hitwall].nextwall >= 0)
@@ -6766,6 +6764,7 @@
 
 #else /* POLYMOST */
 
+#include "inttypes.h"
 int32_t polymost_drawtilescreen (int32_t tilex, int32_t tiley, int32_t wallnum, int32_t dimen) { return -1; }
 
 #endif
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/sdlayer.c ./build/src/sdlayer.c
--- /home/terminx/eduke32_src_20090131/build/src/sdlayer.c	2009-01-31 02:23:02.181791000 -0800
+++ ./build/src/sdlayer.c	2009-02-27 23:44:54.535084000 -0800
@@ -341,6 +341,7 @@
     va_end(va);
 
     OSD_Printf(buf);
+    Bprintf(buf);
 
     if (Bstrlen(dabuf) + Bstrlen(buf) > 1022)
     {
diff -urEBwb /home/terminx/eduke32_src_20090131/build/src/winlayer.c ./build/src/winlayer.c
--- /home/terminx/eduke32_src_20090131/build/src/winlayer.c	2009-01-31 02:23:02.772778000 -0800
+++ ./build/src/winlayer.c	2009-02-19 08:47:54.128197000 -0800
@@ -87,7 +87,7 @@
 static void UninitDirectInput(void);
 static void GetKeyNames(void);
 static void AcquireInputDevices(char acquire, int8_t device);
-static void ProcessInputDevices(void);
+static inline void ProcessInputDevices(void);
 static int32_t SetupDirectDraw(int32_t width, int32_t height);
 static void UninitDIB(void);
 static int32_t SetupDIB(int32_t width, int32_t height);
@@ -1664,7 +1664,7 @@
 //
 // ProcessInputDevices() -- processes the input devices
 //
-static void ProcessInputDevices(void)
+static inline void ProcessInputDevices(void)
 {
     DWORD i;
     HRESULT result;
@@ -2005,7 +2005,7 @@
 //
 // sampletimer() -- update totalclock
 //
-void sampletimer(void)
+inline void sampletimer(void)
 {
     int64 i;
     int32_t n;
@@ -2335,7 +2335,7 @@
 {
     static int32_t defaultres[][2] =
     {
-        {1280,1024},{1280,960},{1152,864},{1024,768},{800,600},{640,480},
+        {1920,1440},{1920,1200},{1600,1200},{1280,1024},{1280,960},{1152,864},{1024,768},{1024,600},{800,600},{640,480},
         {640,400},{512,384},{480,360},{400,300},{320,240},{320,200},{0,0}
     };
     int32_t cdepths[2] = { 8, 0 };
diff -urEBwb /home/terminx/eduke32_src_20090131/Makefile ./Makefile
--- /home/terminx/eduke32_src_20090131/Makefile	2009-01-31 18:53:50.446782543 -0800
+++ ./Makefile	2009-03-14 07:57:25.342643690 -0700
@@ -47,6 +47,7 @@
 
 CC=gcc
 CXX=g++
+AS=nasm
 
 GCC_MAJOR    := $(shell $(CC) -dumpversion 2>&1 | cut -d'.' -f1)
 GCC_MINOR    := $(shell $(CC) -dumpversion 2>&1 | cut -d'.' -f2)
@@ -298,10 +299,10 @@
 # RULES
 $(OBJ)/%.$o: $(SRC)/%.nasm
 	$(COMPILE_STATUS)
-	nasm $(NASMFLAGS) $< -o $@
+	$(AS) $(NASMFLAGS) $< -o $@
 $(OBJ)/%.$o: $(SRC)/jaudiolib/%.nasm
 	$(COMPILE_STATUS)
-	nasm $(NASMFLAGS) $< -o $@
+	$(AS) $(NASMFLAGS) $< -o $@
  
 $(OBJ)/%.$o: $(SRC)/%.c
 	$(COMPILE_STATUS)
Only in ./rsrc: game2.psd
diff -urEBwb /home/terminx/eduke32_src_20090131/source/actors.c ./source/actors.c
--- /home/terminx/eduke32_src_20090131/source/actors.c	2009-01-18 16:58:39.984202000 -0800
+++ ./source/actors.c	2009-02-19 08:47:54.128197000 -0800
@@ -2236,6 +2236,44 @@
                 //                if( g_sounds[WIERDSHOT_FLY].num == 0 )
                 //                    A_PlaySound(WIERDSHOT_FLY,i);
 
+                if (ActorExtra[i].projectile.workslike & PROJECTILE_BOUNCESOFFWALLS)
+                {
+                    /*                    if(s->yvel < 1 || s->extra < 2 || (s->xvel|s->zvel) == 0)
+                    Did this cause the bug with prematurely exploding projectiles? */
+                    if (s->yvel < 1)
+                    {
+
+                        if (ActorExtra[i].projectile.spawns >= 0)
+                        {
+                            k = A_Spawn(i,ActorExtra[i].projectile.spawns);
+
+                            Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
+                            /*
+                            sprite[k].x = dax;
+                            sprite[k].y = day;
+                            sprite[k].z = daz;
+                            */
+
+                            if (ActorExtra[i].projectile.sxrepeat > 4)
+                                sprite[k].xrepeat=ActorExtra[i].projectile.sxrepeat;
+                            if (ActorExtra[i].projectile.syrepeat > 4)
+                                sprite[k].yrepeat=ActorExtra[i].projectile.syrepeat;
+                        }
+                        if (ActorExtra[i].projectile.isound >= 0)
+                            A_PlaySound(ActorExtra[i].projectile.isound,i);
+
+                        s->extra=ActorExtra[i].projectile.extra;
+
+                        if (ActorExtra[i].projectile.extra_rand > 0)
+                            s->extra += (krand()&ActorExtra[i].projectile.extra_rand);
+
+                        x = s->extra;
+                        A_RadiusDamage(i,ActorExtra[i].projectile.hitradius, x>>2,x>>1,x-(x>>2),x);
+
+                        KILLIT(i);
+                    }
+                }
+
                 p = -1;
 
                 if (ActorExtra[i].projectile.workslike & PROJECTILE_COOLEXPLOSION1)
@@ -2261,11 +2299,6 @@
                 }
 
                 Bmemcpy(&davect,s,sizeof(vec3_t));
-                /*
-                                dax = s->x;
-                                day = s->y;
-                                daz = s->z;
-                */
 
                 A_GetZLimits(i);
                 qq = CLIPMASK1;
@@ -2326,11 +2359,6 @@
                                 k = A_Spawn(i,ActorExtra[i].projectile.spawns);
 
                                 Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
-                                /*
-                                                                sprite[k].x = dax;
-                                                                sprite[k].y = day;
-                                                                sprite[k].z = daz;
-                                */
 
                                 if (ActorExtra[i].projectile.sxrepeat > 4)
                                     sprite[k].xrepeat=ActorExtra[i].projectile.sxrepeat;
@@ -2352,45 +2380,6 @@
                     }
                 }
 
-                if (ActorExtra[i].projectile.workslike & PROJECTILE_BOUNCESOFFWALLS)
-                {
-                    /*                    if(s->yvel < 1 || s->extra < 2 || (s->xvel|s->zvel) == 0)
-                                Did this cause the bug with prematurely exploding projectiles? */
-                    if (s->yvel < 1)
-                    {
-
-                        if (ActorExtra[i].projectile.spawns >= 0)
-                        {
-                            k = A_Spawn(i,ActorExtra[i].projectile.spawns);
-
-                            Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
-                            /*
-                                                        sprite[k].x = dax;
-                                                        sprite[k].y = day;
-                                                        sprite[k].z = daz;
-                            */
-
-                            if (ActorExtra[i].projectile.sxrepeat > 4)
-                                sprite[k].xrepeat=ActorExtra[i].projectile.sxrepeat;
-                            if (ActorExtra[i].projectile.syrepeat > 4)
-                                sprite[k].yrepeat=ActorExtra[i].projectile.syrepeat;
-                        }
-                        if (ActorExtra[i].projectile.isound >= 0)
-                            A_PlaySound(ActorExtra[i].projectile.isound,i);
-
-                        s->extra=ActorExtra[i].projectile.extra;
-
-                        if (ActorExtra[i].projectile.extra_rand > 0)
-                            s->extra += (krand()&ActorExtra[i].projectile.extra_rand);
-
-                        x = s->extra;
-                        A_RadiusDamage(i,ActorExtra[i].projectile.hitradius, x>>2,x>>1,x-(x>>2),x);
-
-                        KILLIT(i);
-                    }
-
-                }
-
                 if ((j&49152) != 49152)
                     if (!(ActorExtra[i].projectile.workslike & PROJECTILE_BOUNCESOFFWALLS))
                     {
@@ -2399,8 +2388,7 @@
                             j = 16384|(s->sectnum);
                             s->zvel = -1;
                         }
-                        else
-                            if ((s->z > ActorExtra[i].floorz && sector[s->sectnum].lotag != 1) ||
+                        else if ((s->z > ActorExtra[i].floorz && sector[s->sectnum].lotag != 1) ||
                                     (s->z > ActorExtra[i].floorz+(16<<8) && sector[s->sectnum].lotag == 1))
                             {
                                 j = 16384|(s->sectnum);
@@ -2483,11 +2471,6 @@
                             {
                                 k = A_Spawn(i,ActorExtra[i].projectile.spawns);
                                 Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
-                                /*
-                                                                sprite[k].x = dax;
-                                                                sprite[k].y = day;
-                                                                sprite[k].z = daz;
-                                */
 
                                 if (ActorExtra[i].projectile.sxrepeat > 4)
                                     sprite[k].xrepeat=ActorExtra[i].projectile.sxrepeat;
@@ -2582,11 +2565,6 @@
                     {
                         k = A_Spawn(i,ActorExtra[i].projectile.spawns);
                         Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
-                        /*
-                                                sprite[k].x = dax;
-                                                sprite[k].y = day;
-                                                sprite[k].z = daz;
-                        */
 
                         if (ActorExtra[i].projectile.sxrepeat > 4)
                             sprite[k].xrepeat=ActorExtra[i].projectile.sxrepeat;
@@ -2696,11 +2674,6 @@
                 }
 
                 Bmemcpy(&davect,s,sizeof(vec3_t));
-                /*
-                                dax = s->x;
-                                day = s->y;
-                                daz = s->z;
-                */
 
                 A_GetZLimits(i);
                 qq = CLIPMASK1;
@@ -2743,8 +2716,7 @@
                             j = 16384|(s->sectnum);
                             s->zvel = -1;
                         }
-                        else
-                            if ((s->z > ActorExtra[i].floorz && sector[s->sectnum].lotag != 1) ||
+                        else if ((s->z > ActorExtra[i].floorz && sector[s->sectnum].lotag != 1) ||
                                     (s->z > ActorExtra[i].floorz+(16<<8) && sector[s->sectnum].lotag == 1))
                             {
                                 j = 16384|(s->sectnum);
@@ -2892,11 +2864,6 @@
                         {
                             k = A_Spawn(i,EXPLOSION2);
                             Bmemcpy(&sprite[k],&davect,sizeof(vec3_t));
-                            /*
-                                                        sprite[k].x = dax;
-                                                        sprite[k].y = day;
-                                                        sprite[k].z = daz;
-                            */
 
                             if (s->xrepeat < 10)
                             {
@@ -4752,8 +4719,7 @@
                         l += 3;
                     }
                 }
-                else
-                    if (t[0] > 64)
+                else if (t[0] > 64)
                     {
                         t[0]--;
                         l -= 3;
@@ -4852,8 +4818,7 @@
                         if (s->zvel < 64)
                             s->zvel += (g_spriteGravity>>5)+(krand()&7);
                     }
-                    else
-                        if (s->zvel < 144)
+                    else if (s->zvel < 144)
                             s->zvel += (g_spriteGravity>>5)+(krand()&7);
                 }
 
@@ -7509,19 +7474,6 @@
         }
 }
 
-
-inline int32_t A_CheckSpriteFlags(int32_t iActor, int32_t iType)
-{
-    if ((SpriteFlags[sprite[iActor].picnum]^ActorExtra[iActor].flags) & iType) return 1;
-    return 0;
-}
-
-inline int32_t A_CheckSpriteTileFlags(int32_t iPicnum, int32_t iType)
-{
-    if (SpriteFlags[iPicnum] & iType) return 1;
-    return 0;
-}
-
 int32_t A_CheckEnemyTile(int32_t pn)
 {
     //this case can't be handled by the dynamictostatic system because it adds
diff -urEBwb /home/terminx/eduke32_src_20090131/source/astub.c ./source/astub.c
--- /home/terminx/eduke32_src_20090131/source/astub.c	2009-01-31 18:14:23.184781000 -0800
+++ ./source/astub.c	2009-03-13 19:55:39.565179000 -0700
@@ -44,7 +44,7 @@
 #include <shellapi.h>
 #endif
 
-#define BUILDDATE " 20090131"
+#define BUILDDATE " 20090313"
 #define VERSION " 1.2.0devel"
 
 static int32_t floor_over_floor;
@@ -660,8 +660,7 @@
             else Bsprintf(tempbuf,"%s",lo);
         }
     }
-    else
-        if (sprite[spritenum].picnum==SECTOREFFECTOR)
+    else if (sprite[spritenum].picnum==SECTOREFFECTOR)
         {
             if (onnames==8)
                 tempbuf[0] = 0;
@@ -898,8 +897,7 @@
             case SECTOREFFECTOR:
                 if (sprite[i].lotag==10 || sprite[i].lotag==27 || sprite[i].lotag==28 || sprite[i].lotag==29)
                     break;
-                else
-                    if (sprite[i].hitag>nextfreetag) nextfreetag=1+sprite[i].hitag;
+                else if (sprite[i].hitag>nextfreetag) nextfreetag=1+sprite[i].hitag;
                 break;
             default:
                 break;
@@ -5324,8 +5322,7 @@
     {
         if (eitherSHIFT)
             infobox^=1;
-        else
-            if (eitherCTRL)
+        else if (eitherCTRL)
                 infobox^=2;
             else usedcount=!usedcount;
         keystatus[KEYSC_F2] = 0;
@@ -5773,8 +5770,7 @@
                 if (updownunits) {mouseax=0;}
             }
         }
-        else
-            if (eitherCTRL)
+        else if (eitherCTRL)
             {
                 mskip=1;
                 if (mousex!=0)
@@ -5881,8 +5877,7 @@
                 }
             }
         }
-        else
-            if (eitherCTRL)
+        else if (eitherCTRL)
             {
                 mskip=1;
                 if (mousey!=0)
@@ -8628,9 +8623,9 @@
     {
         int32_t i;
 #if 1
-        i=wm_ynbox("Texture Caching",
+        i=wm_ynbox("Texture Cache",
                    "Would you like to enable the on-disk texture cache?\n\n"
-                   "You will generally want to say 'yes' here, especially if using the HRP.");
+                   "You generally want to say 'yes' here, especially if using the HRP.");
 #else
         i = 1;
 #endif
@@ -9526,14 +9521,6 @@
     horiz = ((horiz*7+(100-(daang>>1)))>>3);
     if (horiz < 100) horiz++;
     if (horiz > 100) horiz--;
-    /*
-        if (keystatus[KEYSC_QUOTE] && keystatus[KEYSC_5]) // ' 5
-        {
-            keystatus[KEYSC_5]=0;
-            editstatus = 1;
-            sidemode = 2;
-        }
-        */
 }
 
 extern int16_t brightness;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/config.c ./source/config.c
--- /home/terminx/eduke32_src_20090131/source/config.c	2009-01-30 16:02:14.026819000 -0800
+++ ./source/config.c	2009-03-13 19:55:39.565179000 -0700
@@ -260,6 +260,8 @@
     ud.weaponscale = 100;
     ud.textscale = 100;
 
+    ud.config.CheckForUpdates = 1;
+
     Bstrcpy(ud.rtsname, "DUKE.RTS");
     Bstrcpy(szPlayerName, "Duke");
 
@@ -901,6 +903,7 @@
 
         {
             SCRIPT_GetNumber(ud.config.scripthandle, "Sound Setup", "VoiceToggle",&ud.config.VoiceToggle);
+            // hack to switch old VoiceToggle value over to new bitfield format
             if (ud.config.VoiceToggle == 2) ud.config.VoiceToggle = 5;
         }
 
@@ -958,7 +961,7 @@
 ===================
 */
 
-void CONFIG_WriteBinds(void) // save binds and aliases to disk
+void CONFIG_WriteBinds(void) // save binds and aliases to <cfgname>_binds.cfg
 {
     int32_t i;
     FILE *fp;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/duke3d.h ./source/duke3d.h
--- /home/terminx/eduke32_src_20090131/source/duke3d.h	2009-01-31 18:53:50.449784621 -0800
+++ ./source/duke3d.h	2009-03-14 07:57:25.343642984 -0700
@@ -804,6 +804,7 @@
     GAMEVAR_SHORTPTR   = 0x00008000, // plValues is a pointer to a short
     GAMEVAR_CHARPTR    = 0x00010000, // plValues is a pointer to a char
     GAMEVAR_NORESET    = 0x00020000, // var values are not reset when restoring map state
+    GAMEVAR_SPECIAL    = 0x00040000, // flag for structure member shortcut vars
 };
 
 enum GamearrayFlags_t {
diff -urEBwb /home/terminx/eduke32_src_20090131/source/funct.h ./source/funct.h
--- /home/terminx/eduke32_src_20090131/source/funct.h	2009-01-13 04:23:18.929740000 -0800
+++ ./source/funct.h	2009-03-09 08:53:19.309928000 -0700
@@ -26,7 +26,7 @@
 #define __funct_h__
 
 #ifndef _MSC_VER
-  #ifdef __GNUC__
+  #if defined(__GNUC__) && defined(__i386__) 
     #ifndef __fastcall
       #define __fastcall __attribute__((fastcall))
     #endif
@@ -48,7 +48,7 @@
 extern int32_t A_PlaySound(uint32_t num,int32_t i);
 extern void S_StopSound(int32_t num);
 extern void S_StopEnvSound(int32_t num,int32_t i);
-extern void pan3dsound(void);
+extern void S_Pan3D(void);
 extern void S_TestSoundCallback(uint32_t num);
 extern void S_ClearSoundLocks(void);
 extern int32_t A_CallSound(int32_t sn,int32_t whatsprite);
@@ -80,7 +80,7 @@
 extern void A_DamageObject(int32_t i,int32_t sn);
 extern void allignwarpelevators(void);
 extern void G_HandleSharedKeys(int32_t snum);
-extern void checksectors(int32_t snum);
+extern void P_CheckSectors(int32_t snum);
 extern int32 RTS_AddFile(const char *filename);
 extern void RTS_Init(const char *filename);
 extern int32 RTS_NumSounds(void);
@@ -96,7 +96,7 @@
 extern void P_ResetInventory(int32_t snum);
 extern void G_NewGame(int32_t vn,int32_t ln,int32_t sk);
 extern void G_ResetTimers(void);
-extern void waitforeverybody(void);
+extern void Net_WaitForEverybody(void);
 extern void clearfifo(void);
 extern void Net_ResetPrediction(void);
 extern int32_t  G_EnterLevel(int32_t g);
@@ -220,7 +220,7 @@
 extern void A_LoadActor(int32_t sActor);
 
 extern int32_t Gv_GetVarByLabel(const char *szGameLabel, int32_t lDefault, int32_t iActor, int32_t iPlayer);
-extern void Gv_DumpValues(FILE *fp);
+extern void Gv_DumpValues(void);
 // extern void AddLog(const char *psz, ...);
 
 extern void Gv_ResetSystemDefaults(void);
@@ -255,10 +255,26 @@
 extern void G_AddUserQuote(const char *daquote);
 extern void Net_NewGame(int32_t volume, int32_t level);
 
-extern inline int32_t A_CheckSpriteFlags(int32_t iActor, int32_t iType);
-extern inline int32_t A_CheckSpriteTileFlags(int32_t iPicnum, int32_t iType);
+extern int32_t SpriteFlags[MAXTILES];
 
-extern int32_t G_GetTeamPalette(int32_t team);
+#define A_CheckSpriteFlags(iActor, iType) (((SpriteFlags[sprite[iActor].picnum]^ActorExtra[iActor].flags) & iType) != 0)
+#define A_CheckSpriteTileFlags(iPicnum, iType) ((SpriteFlags[iPicnum] & iType) != 0)
+
+static inline int32_t G_GetTeamPalette(int32_t team)
+{
+    switch (team)
+    {
+    case 0:
+        return 3;
+    case 1:
+        return 10;
+    case 2:
+        return 11;
+    case 3:
+        return 12;
+    }
+    return 0;
+}
 
 extern void se40code(int32_t x,int32_t y,int32_t z,int32_t a,int32_t h, int32_t smoothratio);
 
diff -urEBwb /home/terminx/eduke32_src_20090131/source/game.c ./source/game.c
--- /home/terminx/eduke32_src_20090131/source/game.c	2009-01-31 18:53:50.479778580 -0800
+++ ./source/game.c	2009-03-14 07:59:56.360641221 -0700
@@ -143,7 +143,7 @@
 static int32_t nonsharedtimer;
 
 static void G_DrawCameraText(int16_t i);
-static int32_t G_MoveLoop(void);
+static inline int32_t G_MoveLoop(void);
 static void G_DoOrderScreen(void);
 static void Net_DoPrediction(void);
 static void Net_CorrectPrediction(void);
@@ -643,35 +643,7 @@
                 g_player[i].movefifoend++;
             }
 
-            /*            while (j != packbufleng)
-                        {
-                            for (i=connecthead;i>=0;i=connectpoint2[i])
-                                if (i != myconnectindex)
-                                {
-                                    g_player[i].syncval[g_player[i].syncvalhead&(MOVEFIFOSIZ-1)] = packbuf[j];
-                                    g_player[i].syncvalhead++;
-                                }
-                            j++;
-                        } */
-            /*            while (j != packbufleng)
-                        {
-                            for (i = connecthead; i >= 0; i = connectpoint2[i])
-                            {
-                                if (i != myconnectindex)
-                                {
-                                    for (sb = 0; sb < g_numSyncBytes; sb++)
-                                    {
-                                        g_player[i].syncval[g_player[i].syncvalhead & (SYNCFIFOSIZ - 1)][sb] = packbuf[j + sb];
-                                    }
-
-                                    g_player[i].syncvalhead++;
-                                }
-                            }
-
-                            j += g_numSyncBytes;
-                        } */
-
-            Net_GetSyncInfoFromPacket(packbuf, packbufleng, &j, other);
+            Net_GetSyncData(packbuf, packbufleng, &j, other);
 
             TRAVERSE_CONNECT(i)
             if (i != myconnectindex)
@@ -707,12 +679,7 @@
                         if (k&2048) nsyn[other].extbits = ((nsyn[other].extbits&0x00ffffff)|((int32_t)packbuf[j++])<<24); */
             g_player[other].movefifoend++;
 
-            /*            while (j != packbufleng)
-                        {
-                            g_player[other].syncval[g_player[other].syncvalhead&(MOVEFIFOSIZ-1)] = packbuf[j++];
-                            g_player[other].syncvalhead++;
-                        } */
-            Net_GetSyncInfoFromPacket(packbuf, packbufleng, &j, other);
+            Net_GetSyncData(packbuf, packbufleng, &j, other);
 
             for (i=g_movesPerPacket-1;i>=1;i--)
             {
@@ -765,14 +732,7 @@
                 g_player[other].movefifoend++;
             }
 
-            /*
-                        while (j < packbufleng)
-                        {
-                            g_player[other].syncval[g_player[other].syncvalhead&(MOVEFIFOSIZ-1)] = packbuf[j++];
-                            g_player[other].syncvalhead++;
-                        }
-                        */
-            Net_GetSyncInfoFromPacket(packbuf, packbufleng, &j, other);
+            Net_GetSyncData(packbuf, packbufleng, &j, other);
 
             if (j > packbufleng)
                 initprintf("INVALID GAME PACKET!!! (packet %d, %d too many bytes (%d %d))\n",packbuf[0],j-packbufleng,packbufleng,k);
@@ -1312,7 +1272,7 @@
                     syncvaltail++;
                 } */
 
-        Net_AddSyncInfoToPacket(&j);
+        Net_AddSyncData(&j);
 
         TRAVERSE_CONNECT(i)
         if (i != myconnectindex)
@@ -1397,7 +1357,7 @@
                     packbuf[j++] = g_player[myconnectindex].syncval[syncvaltail&(MOVEFIFOSIZ-1)];
                     syncvaltail++;
                 } */
-        Net_AddSyncInfoToPacket(&j);
+        Net_AddSyncData(&j);
 
         mmulti_sendpacket(connecthead,packbuf,j);
         return;
@@ -1486,7 +1446,7 @@
                     packbuf[j++] = g_player[myconnectindex].syncval[syncvaltail&(MOVEFIFOSIZ-1)];
                     syncvaltail++;
                 } */
-        Net_AddSyncInfoToPacket(&j);
+        Net_AddSyncData(&j);
 
         for (i=connectpoint2[connecthead];i>=0;i=connectpoint2[i])
             if (g_player[i].playerquitflag)
@@ -4608,66 +4568,68 @@
 static void G_DumpDebugInfo(void)
 {
     int32_t i,j,x;
-    FILE * fp=fopen("debug.con","w");
+//    FILE * fp=fopen("condebug.log","w");
+
+    OSD_Printf("Current gamevar values:\n");
     for (i=0;i<MAX_WEAPONS;i++)
     {
         for (j=0;j<numplayers;j++)
         {
-            fprintf(fp,"Player %d\n\n",j);
-            fprintf(fp,"WEAPON%d_CLIP %" PRIdPTR "\n",i,aplWeaponClip[i][j]);
-            fprintf(fp,"WEAPON%d_RELOAD %" PRIdPTR "\n",i,aplWeaponReload[i][j]);
-            fprintf(fp,"WEAPON%d_FIREDELAY %" PRIdPTR "\n",i,aplWeaponFireDelay[i][j]);
-            fprintf(fp,"WEAPON%d_TOTALTIME %" PRIdPTR "\n",i,aplWeaponTotalTime[i][j]);
-            fprintf(fp,"WEAPON%d_HOLDDELAY %" PRIdPTR "\n",i,aplWeaponHoldDelay[i][j]);
-            fprintf(fp,"WEAPON%d_FLAGS %" PRIdPTR "\n",i,aplWeaponFlags[i][j]);
-            fprintf(fp,"WEAPON%d_SHOOTS %" PRIdPTR "\n",i,aplWeaponShoots[i][j]);
-            fprintf(fp,"WEAPON%d_SPAWNTIME %" PRIdPTR "\n",i,aplWeaponSpawnTime[i][j]);
-            fprintf(fp,"WEAPON%d_SPAWN %" PRIdPTR "\n",i,aplWeaponSpawn[i][j]);
-            fprintf(fp,"WEAPON%d_SHOTSPERBURST %" PRIdPTR "\n",i,aplWeaponShotsPerBurst[i][j]);
-            fprintf(fp,"WEAPON%d_WORKSLIKE %" PRIdPTR "\n",i,aplWeaponWorksLike[i][j]);
-            fprintf(fp,"WEAPON%d_INITIALSOUND %" PRIdPTR "\n",i,aplWeaponInitialSound[i][j]);
-            fprintf(fp,"WEAPON%d_FIRESOUND %" PRIdPTR "\n",i,aplWeaponFireSound[i][j]);
-            fprintf(fp,"WEAPON%d_SOUND2TIME %" PRIdPTR "\n",i,aplWeaponSound2Time[i][j]);
-            fprintf(fp,"WEAPON%d_SOUND2SOUND %" PRIdPTR "\n",i,aplWeaponSound2Sound[i][j]);
-            fprintf(fp,"WEAPON%d_RELOADSOUND1 %" PRIdPTR "\n",i,aplWeaponReloadSound1[i][j]);
-            fprintf(fp,"WEAPON%d_RELOADSOUND2 %" PRIdPTR "\n",i,aplWeaponReloadSound2[i][j]);
-            fprintf(fp,"WEAPON%d_SELECTSOUND %" PRIdPTR "\n",i,aplWeaponSelectSound[i][j]);
+            OSD_Printf("Player %d\n\n",j);
+            OSD_Printf("WEAPON%d_CLIP %" PRIdPTR "\n",i,aplWeaponClip[i][j]);
+            OSD_Printf("WEAPON%d_RELOAD %" PRIdPTR "\n",i,aplWeaponReload[i][j]);
+            OSD_Printf("WEAPON%d_FIREDELAY %" PRIdPTR "\n",i,aplWeaponFireDelay[i][j]);
+            OSD_Printf("WEAPON%d_TOTALTIME %" PRIdPTR "\n",i,aplWeaponTotalTime[i][j]);
+            OSD_Printf("WEAPON%d_HOLDDELAY %" PRIdPTR "\n",i,aplWeaponHoldDelay[i][j]);
+            OSD_Printf("WEAPON%d_FLAGS %" PRIdPTR "\n",i,aplWeaponFlags[i][j]);
+            OSD_Printf("WEAPON%d_SHOOTS %" PRIdPTR "\n",i,aplWeaponShoots[i][j]);
+            OSD_Printf("WEAPON%d_SPAWNTIME %" PRIdPTR "\n",i,aplWeaponSpawnTime[i][j]);
+            OSD_Printf("WEAPON%d_SPAWN %" PRIdPTR "\n",i,aplWeaponSpawn[i][j]);
+            OSD_Printf("WEAPON%d_SHOTSPERBURST %" PRIdPTR "\n",i,aplWeaponShotsPerBurst[i][j]);
+            OSD_Printf("WEAPON%d_WORKSLIKE %" PRIdPTR "\n",i,aplWeaponWorksLike[i][j]);
+            OSD_Printf("WEAPON%d_INITIALSOUND %" PRIdPTR "\n",i,aplWeaponInitialSound[i][j]);
+            OSD_Printf("WEAPON%d_FIRESOUND %" PRIdPTR "\n",i,aplWeaponFireSound[i][j]);
+            OSD_Printf("WEAPON%d_SOUND2TIME %" PRIdPTR "\n",i,aplWeaponSound2Time[i][j]);
+            OSD_Printf("WEAPON%d_SOUND2SOUND %" PRIdPTR "\n",i,aplWeaponSound2Sound[i][j]);
+            OSD_Printf("WEAPON%d_RELOADSOUND1 %" PRIdPTR "\n",i,aplWeaponReloadSound1[i][j]);
+            OSD_Printf("WEAPON%d_RELOADSOUND2 %" PRIdPTR "\n",i,aplWeaponReloadSound2[i][j]);
+            OSD_Printf("WEAPON%d_SELECTSOUND %" PRIdPTR "\n",i,aplWeaponSelectSound[i][j]);
         }
-        fprintf(fp,"\n");
+        OSD_Printf("\n");
     }
     for (x=0;x<MAXSTATUS;x++)
     {
         j = headspritestat[x];
         while (j >= 0)
         {
-            fprintf(fp,"Sprite %d (%d,%d,%d) (picnum: %d)\n",j,sprite[j].x,sprite[j].y,sprite[j].z,sprite[j].picnum);
+            OSD_Printf("Sprite %d (%d,%d,%d) (picnum: %d)\n",j,sprite[j].x,sprite[j].y,sprite[j].z,sprite[j].picnum);
             for (i=0;i<g_gameVarCount;i++)
             {
                 if (aGameVars[i].dwFlags & (GAMEVAR_PERACTOR))
                 {
                     if (aGameVars[i].val.plValues[j] != aGameVars[i].lDefault)
                     {
-                        fprintf(fp,"gamevar %s ",aGameVars[i].szLabel);
-                        fprintf(fp,"%" PRIdPTR "",aGameVars[i].val.plValues[j]);
-                        fprintf(fp," GAMEVAR_PERACTOR");
+                        OSD_Printf("gamevar %s ",aGameVars[i].szLabel);
+                        OSD_Printf("%" PRIdPTR "",aGameVars[i].val.plValues[j]);
+                        OSD_Printf(" GAMEVAR_PERACTOR");
                         if (aGameVars[i].dwFlags != GAMEVAR_PERACTOR)
                         {
-                            fprintf(fp," // ");
+                            OSD_Printf(" // ");
                             if (aGameVars[i].dwFlags & (GAMEVAR_SYSTEM))
                             {
-                                fprintf(fp," (system)");
+                                OSD_Printf(" (system)");
                             }
                         }
-                        fprintf(fp,"\n");
+                        OSD_Printf("\n");
                     }
                 }
             }
-            fprintf(fp,"\n");
+            OSD_Printf("\n");
             j = nextspritestat[j];
         }
     }
-    Gv_DumpValues(fp);
-    fclose(fp);
+    Gv_DumpValues();
+//    fclose(fp);
     saveboard("debug.map",&g_player[myconnectindex].ps->posx,&g_player[myconnectindex].ps->posy,&g_player[myconnectindex].ps->posz,&g_player[myconnectindex].ps->ang,&g_player[myconnectindex].ps->cursectnum);
 }
 
@@ -6985,12 +6947,14 @@
         case RPG__STATIC:
 
 #if defined(POLYMOST) && defined(USE_OPENGL)
-            if (getrendermode() >= 3 && usemodels && md_tilehasmodel(t->picnum,t->pal) >= 0 && !(spriteext[i].flags&SPREXT_NOTMD))
+            if (getrendermode() >= 3 && usemodels && md_tilehasmodel(t->picnum,t->pal) >= 0 &&
+                    !(spriteext[i].flags & SPREXT_NOTMD))
             {
                 int32_t v=getangle(t->xvel,t->zvel>>4);
-                if (v>1023)v-=2048;
-                spriteext[i].pitch=v;
 
+                if (v > 1023)
+                    v -= 2048;
+                spriteext[i].pitch = v;
                 t->cstat &= ~4;
                 break;
             }
@@ -7303,7 +7267,8 @@
                 t->cstat |= 4;
         }
 
-        if (g_player[screenpeek].ps->heat_amount > 0 && g_player[screenpeek].ps->heat_on && (A_CheckEnemySprite(s) || A_CheckSpriteFlags(t->owner,SPRITE_NVG) || s->picnum == APLAYER || s->statnum == 13))
+        if (g_player[screenpeek].ps->heat_amount > 0 && g_player[screenpeek].ps->heat_on &&
+                (A_CheckEnemySprite(s) || A_CheckSpriteFlags(t->owner,SPRITE_NVG) || s->picnum == APLAYER || s->statnum == 13))
         {
             t->pal = 6;
             t->shade = 0;
@@ -7768,7 +7733,7 @@
                     g_player[myconnectindex].ps->cheat_phase = 0;
 
                     G_DumpDebugInfo();
-                    Bsprintf(tempbuf,"GAMEVARS DUMPED TO DEBUG.CON");
+                    Bsprintf(tempbuf,"GAMEVARS DUMPED TO LOG");
                     G_AddUserQuote(tempbuf);
                     Bsprintf(tempbuf,"MAP DUMPED TO DEBUG.MAP");
                     G_AddUserQuote(tempbuf);
@@ -9366,10 +9331,16 @@
 static void G_AddGroup(const char *buffer)
 {
     struct strllist *s;
+    char buf[BMAX_PATH];
+
     s = (struct strllist *)Bcalloc(1,sizeof(struct strllist));
-    s->str = Bstrdup(buffer);
-    if (Bstrchr(s->str,'.') == 0)
-        Bstrcat(s->str,".grp");
+
+    Bstrcpy(buf, buffer);
+
+    if (Bstrchr(buf,'.') == 0)
+        Bstrcat(buf,".grp");
+
+    s->str = Bstrdup(buf);
 
     if (CommandGrps)
     {
@@ -9790,6 +9761,7 @@
                         g_noMusic = 1;
                         initprintf("Music off.\n");
                     }
+                    /*
                     else if (*c == 'd' || *c == 'D')
                     {
                         FILE * fp=fopen("gamevars.txt","w");
@@ -9798,6 +9770,7 @@
                         fclose(fp);
                         initprintf("Game variables saved to gamevars.txt.\n");
                     }
+                    */
                     else
                     {
                         G_ShowParameterHelp();
@@ -10115,7 +10088,7 @@
         MOUSE_ClearButton(LEFT_MOUSE);
     }
 
-    waitforeverybody();
+    Net_WaitForEverybody();
 
     flushperms();
     clearview(0L);
@@ -10588,7 +10561,7 @@
         if (i != myconnectindex) mmulti_sendpacket(i,&buf[0],5);
         if ((!g_networkBroadcastMode) && (myconnectindex != connecthead)) break; //slaves in M/S mode only send to master
     }
-    waitforeverybody();
+    Net_WaitForEverybody();
 }
 
 static void Net_SendPlayerOptions(void)
@@ -10897,14 +10870,7 @@
         }
     }
 
-#if defined(POLYMOST) && defined(USE_OPENGL)
-    glusetexcache = glusetexcachecompression = -1;
-#endif
-
-#ifdef _WIN32
-    ud.config.CheckForUpdates = -1;
-#endif
-
+    // used with binds for fast function lookup
     hash_init(&gamefuncH);
     for (i=NUMGAMEFUNCTIONS-1;i>=0;i--)
     {
@@ -10914,21 +10880,21 @@
         Bfree(str);
     }
 
-    i = CONFIG_ReadSetup();
-    if (getenv("DUKE3DGRP")) duke3dgrp = getenv("DUKE3DGRP");
-
 #if defined(POLYMOST) && defined(USE_OPENGL)
-    if (glusetexcache == -1 || glusetexcachecompression == -1)
-    {
-        i=wm_ynbox("Texture Caching",
-                   "Would you like to enable the on-disk texture cache?\n\n"
-                   "You will generally want to say 'yes' here, especially if using the HRP.");
-        if (i) ud.config.useprecache = glusetexcompr = glusetexcache = glusetexcachecompression = 1;
-        else glusetexcache = glusetexcachecompression = 0;
-    }
+    glusetexcache = glusetexcachecompression = -1;
+#endif
+
+/*
+#ifdef _WIN32
+    ud.config.CheckForUpdates = -1;
 #endif
+*/
+
+    i = CONFIG_ReadSetup();
+    if (getenv("DUKE3DGRP")) duke3dgrp = getenv("DUKE3DGRP");
 
 #ifdef _WIN32
+/*
     if (ud.config.CheckForUpdates == -1)
     {
         i=wm_ynbox("Automatic Update Notifications",
@@ -10936,6 +10902,7 @@
         ud.config.CheckForUpdates = 0;
         if (i) ud.config.CheckForUpdates = 1;
     }
+*/
 
 //    initprintf("build %d\n",(uint8_t)atoi(BUILDDATE));
 
@@ -10967,12 +10934,6 @@
 
                         if (!ShellExecuteExA(&sinfo))
                             initprintf("update: error launching browser!\n");
-                        /*
-                                                CONFIG_SetupMouse();
-                                                CONFIG_SetupJoystick();
-                                                CONFIG_WriteSetup();
-                                                G_GameExit(" ");
-                        */
                     }
                 }
                 else initprintf("... no updates available\n");
@@ -10981,6 +10942,18 @@
         }
     }
 #endif
+
+#if defined(POLYMOST) && defined(USE_OPENGL)
+    if (glusetexcache == -1 || glusetexcachecompression == -1)
+    {
+        i=wm_ynbox("Texture Cache",
+            "Would you like to enable the on-disk texture cache?\n\n"
+            "You generally want to say 'yes' here, especially if using the HRP.");
+        if (i) ud.config.useprecache = glusetexcompr = glusetexcache = glusetexcachecompression = 1;
+        else glusetexcache = glusetexcachecompression = 0;
+    }
+#endif
+
     if (preinitengine())
     {
         wm_msgbox("Build Engine Initialization Error",
@@ -10994,7 +10967,7 @@
     {
         // try and identify the 'defaultduke3dgrp' in the set of GRPs.
         // if it is found, set up the environment accordingly for the game it represents.
-        // if it is not found, choose the first GRP from the list of
+        // if it is not found, choose the first GRP from the list
         struct grpfile *fg, *first = NULL;
         int32_t i;
         for (fg = foundgrps; fg; fg=fg->next)
@@ -11147,7 +11120,7 @@
     i = initgroupfile(duke3dgrp);
 
     if (i == -1)
-        initprintf("Warning: could not find group file '%s'!\n",duke3dgrp);
+        initprintf("Warning: could not find main group file '%s'!\n",duke3dgrp);
     else
         initprintf("Using group file '%s' as main group file.\n", duke3dgrp);
 
@@ -11208,8 +11181,8 @@
                     G_DoAutoload(CommandGrps->str);
             }
 
-            free(CommandGrps->str);
-            free(CommandGrps);
+            Bfree(CommandGrps->str);
+            Bfree(CommandGrps);
             CommandGrps = s;
         }
         pathsearchmode = 0;
@@ -11294,7 +11267,7 @@
         Net_SendWeaponChoice();
         Net_SendUserMapName();
         Net_GetPackets();
-        waitforeverybody();
+        Net_WaitForEverybody();
     }
     else if (boardfilename[0] != 0)
     {
@@ -11467,7 +11440,7 @@
                 ud.m_respawn_monsters = 1;
             else ud.m_respawn_monsters = 0;
 
-            waitforeverybody();
+            Net_WaitForEverybody();
 
             TRAVERSE_CONNECT(i)
             {
@@ -11546,7 +11519,7 @@
             if (g_player[myconnectindex].ps->gm&MODE_EOL)
             {
                 G_CloseDemoWrite();
-                waitforeverybody();
+                Net_WaitForEverybody();
 
                 ready2send = 0;
 
@@ -11581,7 +11554,7 @@
             }
             ud.display_bonus_screen = 1;
             ready2send = 0;
-            waitforeverybody();
+            Net_WaitForEverybody();
             if (numplayers > 1) g_player[myconnectindex].ps->gm = MODE_GAME;
             if (G_EnterLevel(g_player[myconnectindex].ps->gm))
             {
@@ -11678,8 +11651,7 @@
     {
         if ((recfilep = kopen4loadfrommod(firstdemofile,g_loadFromGroupOnly)) == -1) return(0);
     }
-    else
-        if ((recfilep = kopen4loadfrommod(d,g_loadFromGroupOnly)) == -1) return(0);
+    else if ((recfilep = kopen4loadfrommod(d,g_loadFromGroupOnly)) == -1) return(0);
 
     if (kread(recfilep,&ud.reccnt,sizeof(int32_t)) != sizeof(int32_t)) goto corrupt;
     if (kread(recfilep,&ver,sizeof(uint8_t)) != sizeof(uint8_t)) goto corrupt;
@@ -12045,7 +12017,7 @@
     return 1;
 }
 
-static int32_t G_MoveLoop()
+static inline int32_t G_MoveLoop()
 {
     int32_t i;
 
@@ -12764,7 +12736,7 @@
         if (ud.pause_on == 0)
         {
             P_ProcessInput(i);
-            checksectors(i);
+            P_CheckSectors(i);
         }
     }
 
@@ -12777,7 +12749,7 @@
     {
         G_AnimateWalls();
         A_MoveCyclers();
-        pan3dsound();
+        S_Pan3D();
     }
 
     return 0;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/gamedef.c ./source/gamedef.c
--- /home/terminx/eduke32_src_20090131/source/gamedef.c	2009-01-31 01:15:25.054778000 -0800
+++ ./source/gamedef.c	2009-03-13 19:55:39.565179000 -0700
@@ -38,6 +38,7 @@
 
 intptr_t *g_caseScriptPtr=NULL;      // the pointer to the start of the case table in a switch statement
 // first entry is 'default' code.
+static intptr_t *previous_event=NULL;
 static int32_t g_numCases = 0;
 static int32_t g_checkingSwitch = 0, g_currentEvent = -1;
 static int32_t g_labelsOnly = 0, g_skipKeywordCheck = 0, g_dynamicTileMapping = 0;
@@ -486,6 +487,7 @@
     "ifvarvareither",           // 342
     "getarraysize",             // 343
     "savenn",                   // 344
+    "copy",                     // 345
     "<null>"
 };
 
@@ -2773,17 +2775,12 @@
             g_numCompilerErrors++;
             return 0;
         }
-
+        // if event has already been declared then store previous script location
         if (apScriptGameEvent[j])
         {
-            tempscrptr = g_parsingEventPtr;
-            g_parsingEventPtr = g_parsingActorPtr = 0;
-            C_ReportError(-1);
-            g_parsingEventPtr = g_parsingActorPtr = tempscrptr;
-            initprintf("%s:%d: warning: duplicate event `%s'.\n",g_szScriptFileName,g_lineNumber,g_szCurrentBlockName);
-            g_numCompilerWarnings++;
+            previous_event =apScriptGameEvent[j];
         }
-        else apScriptGameEvent[j]=g_parsingEventPtr;
+        apScriptGameEvent[j]=g_parsingEventPtr;
 
         g_checkingIfElse = 0;
 
@@ -3863,6 +3860,46 @@
 
         C_GetNextValue(LABEL_DEFINE); // the number to check against...
         return 0;
+    case CON_WRITEARRAYTOFILE:
+    case CON_READARRAYFROMFILE:
+        C_GetNextLabelName();
+        i=GetADefID(label+(g_numLabels<<6));
+        if (i > (-1))
+        {
+            bitptr[(g_scriptPtr-script)>>3] &= ~(1<<((g_scriptPtr-script)&7));
+            *g_scriptPtr++=i;
+        }
+        else
+            C_ReportError(ERROR_NOTAGAMEARRAY);
+        C_GetNextValue(LABEL_DEFINE);
+        return 0;
+    case CON_COPY:
+        C_GetNextLabelName();
+        i=GetADefID(label+(g_numLabels<<6));
+        if (i > (-1))
+        {
+            bitptr[(g_scriptPtr-script)>>3] &= ~(1<<((g_scriptPtr-script)&7));
+            *g_scriptPtr++=i;
+        }
+        else
+            C_ReportError(ERROR_NOTAGAMEARRAY);
+        C_SkipComments();// skip comments and whitespace
+        if (*textptr != '[')
+        {
+            g_numCompilerErrors++;
+            C_ReportError(ERROR_GAMEARRAYBNO);
+            return 1;
+        }
+        textptr++;
+        C_GetNextVar();
+        C_SkipComments();// skip comments and whitespace
+        if (*textptr != ']')
+        {
+            g_numCompilerErrors++;
+            C_ReportError(ERROR_GAMEARRAYBNC);
+            return 1;
+        }
+        textptr++;
     case CON_SETARRAY:
         C_GetNextLabelName();
         i=GetADefID(label+(g_numLabels<<6));
@@ -4884,7 +4922,8 @@
 
         if (j < 0 || j > MAXVOLUMES-1)
         {
-            initprintf("%s:%d: error: volume number exceeds maximum volume count.\n",g_szScriptFileName,g_lineNumber);
+            initprintf("%s:%d: error: volume number exceeds maximum volume count.\n",
+                       g_szScriptFileName,g_lineNumber);
             g_numCompilerErrors++;
             while (*textptr != 0x0a && *textptr != 0) textptr++;
             break;
@@ -4898,8 +4937,9 @@
             textptr++,i++;
             if (i >= (signed)sizeof(EpisodeNames[j])-1)
             {
-                initprintf("%s:%d: error: volume name exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,sizeof(EpisodeNames[j])-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating volume name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,sizeof(EpisodeNames[j])-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -4917,7 +4957,8 @@
 
         if (j < 0 || j > NUMGAMEFUNCTIONS-1)
         {
-            initprintf("%s:%d: error: function number exceeds number of game functions.\n",g_szScriptFileName,g_lineNumber);
+            initprintf("%s:%d: error: function number exceeds number of game functions.\n",
+                       g_szScriptFileName,g_lineNumber);
             g_numCompilerErrors++;
             while (*textptr != 0x0a && *textptr != 0) textptr++;
             break;
@@ -4932,14 +4973,16 @@
             textptr++,i++;
             if (*textptr == '/' || *textptr == ' ')
             {
-                initprintf("%s:%d: warning: invalid character in function name.\n",g_szScriptFileName,g_lineNumber);
+                initprintf("%s:%d: warning: invalid character in function name.\n",
+                           g_szScriptFileName,g_lineNumber);
                 g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
             if (i >= MAXGAMEFUNCLEN-1)
             {
-                initprintf("%s:%d: warning: function name exceeds limit of %d characters, truncating.\n",g_szScriptFileName,g_lineNumber,MAXGAMEFUNCLEN);
+                initprintf("%s:%d: warning: truncating function name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,MAXGAMEFUNCLEN);
                 g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
@@ -4966,7 +5009,8 @@
 
         if (j < 0 || j > 4)
         {
-            initprintf("%s:%d: error: skill number exceeds maximum skill count.\n",g_szScriptFileName,g_lineNumber);
+            initprintf("%s:%d: error: skill number exceeds maximum skill count.\n",
+                       g_szScriptFileName,g_lineNumber);
             g_numCompilerErrors++;
             while (*textptr != 0x0a && *textptr != 0) textptr++;
             break;
@@ -4980,8 +5024,9 @@
             textptr++,i++;
             if (i >= (signed)sizeof(SkillNames[j])-1)
             {
-                initprintf("%s:%d: error: skill name exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,sizeof(SkillNames[j])-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating skill name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,sizeof(SkillNames[j])-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -5004,8 +5049,9 @@
             textptr++,i++;
             if (i >= (signed)sizeof(gamename)-1)
             {
-                initprintf("%s:%d: error: game name exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,sizeof(gamename)-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating game name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,sizeof(gamename)-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -5058,6 +5104,10 @@
         {
             char temp[BMAX_PATH];
             struct stat st;
+            int32_t fullscreen = ud.config.ScreenMode;
+            int32_t xdim = ud.config.ScreenWidth, ydim = ud.config.ScreenHeight, bpp = ud.config.ScreenBPP;
+            int32_t usemouse = ud.config.UseMouse, usejoy = ud.config.UseJoystick;
+
             if (stat(mod_dir, &st) < 0)
             {
                 if (errno == ENOENT)     // path doesn't exist
@@ -5080,13 +5130,25 @@
                 // directory isn't a directory
                 return 0;
             }
+
             Bstrcpy(temp,tempbuf);
             CONFIG_WriteSetup();
+            if (mod_dir[0] != '/')
             Bsprintf(setupfilename,"%s/",mod_dir);
+            else setupfilename[0] = 0;
             Bstrcat(setupfilename,temp);
+
+            initprintf("Using config file '%s'.\n",setupfilename);
+
             CONFIG_ReadSetup();
+
+            ud.config.ScreenMode = fullscreen;
+            ud.config.ScreenWidth = xdim;
+            ud.config.ScreenHeight = ydim;
+            ud.config.ScreenBPP = bpp;
+            ud.config.UseMouse = usemouse;
+            ud.config.UseJoystick = usejoy;
         }
-        initprintf("Using config file '%s'.\n",setupfilename);
     }
     return 0;
 
@@ -5119,8 +5181,9 @@
             textptr++,i++;
             if (i >= (signed)sizeof(GametypeNames[j])-1)
             {
-                initprintf("%s:%d: error: gametype name exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,sizeof(GametypeNames[j])-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating gametype name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,sizeof(GametypeNames[j])-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -5206,8 +5269,9 @@
             textptr++,i++;
             if (i >= 32)
             {
-                initprintf("%s:%d: error: level name exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,32);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating level name to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,32);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -5288,8 +5352,8 @@
             textptr++,i++;
             if (i >= MAXQUOTELEN-1)
             {
-                initprintf("%s:%d: error: quote text exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,MAXQUOTELEN-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating quote text to %d characters.\n",g_szScriptFileName,g_lineNumber,MAXQUOTELEN-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0) textptr++;
                 break;
             }
@@ -5336,8 +5400,9 @@
             textptr++,i++;
             if (i >= (signed)sizeof(CheatStrings[k])-1)
             {
-                initprintf("%s:%d: error: cheat exceeds limit of %d characters.\n",g_szScriptFileName,g_lineNumber,MAXCHEATLEN,sizeof(CheatStrings[k])-1);
-                g_numCompilerErrors++;
+                initprintf("%s:%d: warning: truncating cheat string to %d characters.\n",
+                           g_szScriptFileName,g_lineNumber,MAXCHEATLEN,sizeof(CheatStrings[k])-1);
+                g_numCompilerWarnings++;
                 while (*textptr != 0x0a && *textptr != 0x0d && *textptr != 0 && *textptr != ' ') textptr++;
                 break;
             }
@@ -5415,6 +5480,16 @@
             C_ReportError(ERROR_CLOSEBRACKET);
             g_numCompilerErrors++;
         }
+        // if event has already been declared then put a jump in instead
+        if (previous_event)
+        {
+            g_scriptPtr--;
+            *(g_scriptPtr++) = CON_JUMP;
+            *(g_scriptPtr++) = MAXGAMEVARS;
+            *(g_scriptPtr++) = previous_event-script;
+            *(g_scriptPtr++) = CON_ENDEVENT;
+            previous_event = NULL;
+        }
         g_parsingEventPtr = 0;
         g_parsingActorPtr = 0;
         g_currentEvent = -1;
@@ -5597,45 +5672,6 @@
     return 0;
 }
 
-/*
-#define NUM_DEFAULT_CONS    4
-static const char *defaultcons[NUM_DEFAULT_CONS] =
-{
-    "EDUKE.CON",
-    "GAME.CON",
-    "USER.CON",
-    "DEFS.CON"
-};
-
-void copydefaultcons(void)
-{
-    int32_t i, fs, fpi;
-    FILE *fpo;
-
-    for (i=0;i<NUM_DEFAULT_CONS;i++)
-    {
-        fpi = kopen4loadfrommod((char *)defaultcons[i] , 1);
-        if (fpi < 0) continue;
-
-        fpo = fopenfrompath((char *)defaultcons[i],"wb");
-
-        if (fpo == NULL)
-        {
-            kclose(fpi);
-            continue;
-        }
-
-        fs = kfilelength(fpi);
-
-        kread(fpi,&ActorExtra[0],fs);
-        if (fwrite(&ActorExtra[0],fs,1,fpo)==0)initprintf("Failed to restore default CONs.\n");
-
-        kclose(fpi);
-        fclose(fpo);
-    }
-}
-*/
-
 /* Anything added with C_AddDefinition() cannot be overwritten in the CONs */
 
 static void C_AddDefinition(const char *lLabel,int32_t lValue,int32_t lType)
@@ -5818,23 +5854,6 @@
     Gv_Init();
     C_InitProjectiles();
 
-    /* JBF 20040109: Don't prompt to extract CONs from GRP if they're missing.
-     * If someone really wants them they can Kextract them.
-    if(!SafeFileExists(filenam) && g_loadFromGroupOnly == 0)
-    {
-        initprintf("Missing external CON file(s).\n");
-        initprintf("COPY INTERNAL DEFAULTS TO DIRECTORY(Y/n)?\n");
-
-    i=wm_ynbox("Missing CON file(s)", "Missing external CON file(s). "
-    "Copy internal defaults to directory?");
-    if (i) i = 'y';
-        if(i == 'y' || i == 'Y')
-        {
-            initprintf(" Yes\n");
-            copydefaultcons();
-        }
-    }
-    */
     fp = kopen4loadfrommod((char *)filenam,g_loadFromGroupOnly);
     if (fp == -1) // JBF: was 0
     {
diff -urEBwb /home/terminx/eduke32_src_20090131/source/gamedef.h ./source/gamedef.h
--- /home/terminx/eduke32_src_20090131/source/gamedef.h	2009-01-12 20:40:56.000875000 -0800
+++ ./source/gamedef.h	2009-02-19 01:39:19.256754000 -0800
@@ -900,6 +900,7 @@
     CON_IFVARVAREITHER,     // 342
     CON_GETARRAYSIZE,       // 343
     CON_SAVENN,             // 344
+    CON_COPY,               // 345
     CON_END
 };
 #endif
diff -urEBwb /home/terminx/eduke32_src_20090131/source/gameexec.c ./source/gameexec.c
--- /home/terminx/eduke32_src_20090131/source/gameexec.c	2009-01-31 18:53:50.507778417 -0800
+++ ./source/gameexec.c	2009-03-14 07:57:25.377644396 -0700
@@ -2167,7 +2167,9 @@
             int32_t x2=scale(Gv_GetVarX(*insptr++),xdim,320);
             int32_t y2=scale(Gv_GetVarX(*insptr++),ydim,200);
             int32_t smoothratio = min(max((totalclock - ototalclock) * (65536 / TICSPERFRAME),0),65536);
+#if defined(USE_OPENGL) && defined(POLYMOST)
             int32_t j;
+#endif
 
             if (x1 > x2) swaplong(&x1,&x2);
             if (y1 > y2) swaplong(&y1,&y2);
@@ -3664,6 +3666,56 @@
             aGameArrays[j].plValues[index]=value;
             break;
         }
+    case CON_WRITEARRAYTOFILE:
+    case CON_READARRAYFROMFILE:
+        insptr++;
+        {
+            int32_t j=*insptr++;
+            {
+                int q = *insptr++;
+
+                if (ScriptQuotes[q] == NULL)
+                {
+                    OSD_Printf(CON_ERROR "null quote %d\n",g_errorLineNum,keyw[g_tw],q);
+                    break;
+                }
+
+                if (tw == CON_READARRAYFROMFILE)
+                {
+                    int32_t fil = kopen4loadfrommod(ScriptQuotes[q], 0);
+                    int32_t asize;
+
+                    if (fil < 0)
+                        break;
+
+                    asize = kfilelength(fil);
+
+                    if (asize > 0)
+                    {
+                        OSD_Printf(OSDTEXT_GREEN "CON_RESIZEARRAY: resizing array %s from %d to %d\n", aGameArrays[j].szLabel, aGameArrays[j].size, asize);
+                        aGameArrays[j].plValues=Brealloc(aGameArrays[j].plValues, sizeof(int) * asize);
+                        aGameArrays[j].size = asize;
+                    }
+
+                    kread(fil,aGameArrays[j].plValues,sizeof(int) * asize);
+                    kclose(fil);
+                }
+                else
+                {
+                    FILE *fil;
+                    char temp[BMAX_PATH];
+                    if (mod_dir[0] != '/')
+                        Bsprintf(temp,"%s/%s",mod_dir,ScriptQuotes[q]);
+                    else Bsprintf(temp,"%s",ScriptQuotes[q]);
+                    if ((fil = fopen(temp,"wb")) == 0) break;
+
+                    fwrite(aGameArrays[j].plValues,1,sizeof(int) * aGameArrays[j].size,fil);
+                    fclose(fil);
+                }
+                break;
+            }
+        }
+
     case CON_GETARRAYSIZE:
         insptr++;
         {
@@ -3686,6 +3738,24 @@
             break;
         }
 
+    case CON_COPY:
+        insptr++;
+        {
+            int32_t j=*insptr++;
+            {
+                int32_t index = Gv_GetVar(*insptr++, vm.g_i, vm.g_p);
+                int32_t j1=*insptr++;
+                int32_t index1 = Gv_GetVar(*insptr++, vm.g_i, vm.g_p);
+                int32_t value = Gv_GetVar(*insptr++, vm.g_i, vm.g_p);
+                if (index>aGameArrays[j].size) break;
+                if (index1>aGameArrays[j1].size) break;
+                if ((index+value)>aGameArrays[j].size) value=aGameArrays[j].size-index;
+                if ((index1+value)>aGameArrays[j1].size) value=aGameArrays[j1].size-index1;
+                memcpy(aGameArrays[j1].plValues+index1,aGameArrays[j].plValues+index,value*sizeof(int));
+                break;
+            }
+        }
+
     case CON_RANDVAR:
         insptr++;
         Gv_SetVarX(*insptr, mulscale16(krand(), *(insptr+1)+1));
@@ -3694,7 +3764,7 @@
 
     case CON_DISPLAYRANDVAR:
         insptr++;
-        Gv_SetVarX(*insptr, mulscale15(rand(), *(insptr+1)+1));
+        Gv_SetVarX(*insptr, mulscale15((uint16_t)rand(), *(insptr+1)+1));
         insptr += 2;
         break;
 
@@ -3766,7 +3836,7 @@
         insptr++;
         {
             int32_t j=*insptr++;
-            Gv_SetVarX(j,mulscale(rand(), Gv_GetVarX(*insptr++)+1, 15));
+            Gv_SetVarX(j,mulscale((uint16_t)rand(), Gv_GetVarX(*insptr++)+1, 15));
         }
         break;
 
@@ -4808,7 +4878,7 @@
 
         Net_ResetPrediction();
 
-        waitforeverybody();
+        Net_WaitForEverybody();
         mmulti_flushpackets();
         clearfifo();
         G_ResetTimers();
diff -urEBwb /home/terminx/eduke32_src_20090131/source/gamevars.c ./source/gamevars.c
--- /home/terminx/eduke32_src_20090131/source/gamevars.c	2009-01-21 14:43:44.298665000 -0800
+++ ./source/gamevars.c	2009-02-19 08:47:54.128197000 -0800
@@ -303,46 +303,47 @@
     dfwrite(g_szBuf,l,1,fil);
 }
 
-void Gv_DumpValues(FILE *fp)
+void Gv_DumpValues(void)
 {
     int32_t i;
 
-    if (!fp)
-        return;
-
-    fprintf(fp,"// Current Game Definitions\n\n");
+    OSD_Printf("// Current Game Definitions\n\n");
 
     for (i=0;i<g_gameVarCount;i++)
     {
         if (aGameVars[i].dwFlags & (GAMEVAR_SECRET))
             continue; // do nothing...
 
-        fprintf(fp,"gamevar %s ",aGameVars[i].szLabel);
+        OSD_Printf("gamevar %s ",aGameVars[i].szLabel);
 
         if (aGameVars[i].dwFlags & (GAMEVAR_INTPTR))
-            fprintf(fp,"%d",*((int32_t*)aGameVars[i].val.lValue));
+            OSD_Printf("%d",*((int32_t*)aGameVars[i].val.lValue));
         else if (aGameVars[i].dwFlags & (GAMEVAR_SHORTPTR))
-            fprintf(fp,"%d",*((int16_t*)aGameVars[i].val.lValue));
+            OSD_Printf("%d",*((int16_t*)aGameVars[i].val.lValue));
         else if (aGameVars[i].dwFlags & (GAMEVAR_CHARPTR))
-            fprintf(fp,"%d",*((char*)aGameVars[i].val.lValue));
+            OSD_Printf("%d",*((char*)aGameVars[i].val.lValue));
         else
-            fprintf(fp,"%" PRIdPTR "",aGameVars[i].val.lValue);
+            OSD_Printf("%" PRIdPTR "",aGameVars[i].val.lValue);
+
         if (aGameVars[i].dwFlags & (GAMEVAR_PERPLAYER))
-            fprintf(fp," GAMEVAR_PERPLAYER");
+            OSD_Printf(" GAMEVAR_PERPLAYER");
         else if (aGameVars[i].dwFlags & (GAMEVAR_PERACTOR))
-            fprintf(fp," GAMEVAR_PERACTOR");
+            OSD_Printf(" GAMEVAR_PERACTOR");
         else
-            fprintf(fp," %d",aGameVars[i].dwFlags & (GAMEVAR_USER_MASK));
-        fprintf(fp," // ");
+            OSD_Printf(" %d",aGameVars[i].dwFlags/* & (GAMEVAR_USER_MASK)*/);
+
+        OSD_Printf(" // ");
         if (aGameVars[i].dwFlags & (GAMEVAR_SYSTEM))
-            fprintf(fp," (system)");
+            OSD_Printf(" (system)");
         if (aGameVars[i].dwFlags & (GAMEVAR_INTPTR|GAMEVAR_SHORTPTR|GAMEVAR_CHARPTR))
-            fprintf(fp," (pointer)");
+            OSD_Printf(" (pointer)");
         if (aGameVars[i].dwFlags & (GAMEVAR_READONLY))
-            fprintf(fp," (read only)");
-        fprintf(fp,"\n");
+            OSD_Printf(" (read only)");
+        if (aGameVars[i].dwFlags & (GAMEVAR_SPECIAL))
+            OSD_Printf(" (special)");
+        OSD_Printf("\n");
     }
-    fprintf(fp,"\n// end of game definitions\n");
+    OSD_Printf("\n// end of game definitions\n");
 }
 
 void Gv_ResetVars(void) /* this is called during a new game and nowhere else */
@@ -564,6 +565,7 @@
                         return -1;
                     }
                     label = Gv_GetVar(*insptr++, index, iPlayer);
+//                    OSD_Printf("actorvar returned %d\n",label);
                 }
                 else label = *insptr++;
 
@@ -776,7 +778,7 @@
                         OSD_Printf(CON_ERROR "Gv_GetVar(): invalid array index\n",g_errorLineNum,keyw[g_tw]);
                         return -1;
                     }
-                    label = Gv_GetVarX(*insptr++);
+                    label = Gv_GetVar(*insptr++, index, vm.g_p);
                 }
                 else label = *insptr++;
 
@@ -1502,11 +1504,11 @@
     Gv_NewVar("THISACTOR", 0, GAMEVAR_READONLY | GAMEVAR_SYSTEM);
 
     // special vars for struct access
-    Gv_NewVar("sprite", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_INTPTR);
-    Gv_NewVar("sector", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_INTPTR);
-    Gv_NewVar("wall", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_INTPTR);
-    Gv_NewVar("player", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_INTPTR);
-    Gv_NewVar("actorvar", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_INTPTR);
+    Gv_NewVar("sprite", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_SPECIAL);
+    Gv_NewVar("sector", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_SPECIAL);
+    Gv_NewVar("wall", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_SPECIAL);
+    Gv_NewVar("player", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_SPECIAL);
+    Gv_NewVar("actorvar", -1, GAMEVAR_READONLY | GAMEVAR_SYSTEM | GAMEVAR_SPECIAL);
 
     Gv_NewVar("myconnectindex", (intptr_t)&myconnectindex, GAMEVAR_READONLY | GAMEVAR_INTPTR | GAMEVAR_SYSTEM | GAMEVAR_SYNCCHECK);
     Gv_NewVar("screenpeek", (intptr_t)&screenpeek, GAMEVAR_READONLY | GAMEVAR_INTPTR | GAMEVAR_SYSTEM | GAMEVAR_SYNCCHECK);
diff -urEBwb /home/terminx/eduke32_src_20090131/source/global.c ./source/global.c
--- /home/terminx/eduke32_src_20090131/source/global.c	2009-01-31 18:14:16.775779000 -0800
+++ ./source/global.c	2009-03-13 19:55:39.565179000 -0700
@@ -23,7 +23,7 @@
 //-------------------------------------------------------------------------
 #include "duke3d.h"
 
-const char *s_buildDate = "20090131";
+const char *s_buildDate = "20090313";
 char *MusicPtr = NULL;
 int32_t g_musicSize;
 
diff -urEBwb /home/terminx/eduke32_src_20090131/source/jaudiolib/_multivc.h ./source/jaudiolib/_multivc.h
--- /home/terminx/eduke32_src_20090131/source/jaudiolib/_multivc.h	2009-01-09 01:29:17.505954000 -0800
+++ ./source/jaudiolib/_multivc.h	2009-02-19 01:39:19.256754000 -0800
@@ -80,7 +80,7 @@
 #define NumberOfBuffers   16
 #define TotalBufferSize   ( MixBufferSize * NumberOfBuffers )
 
-#define PI                3.1415926536
+#define PI                3.14159265358979323
 
 typedef enum
 {
diff -urEBwb /home/terminx/eduke32_src_20090131/source/jaudiolib/openal.c ./source/jaudiolib/openal.c
--- /home/terminx/eduke32_src_20090131/source/jaudiolib/openal.c	2009-01-09 01:29:17.505954000 -0800
+++ ./source/jaudiolib/openal.c	2009-03-14 07:36:05.553641000 -0700
@@ -275,9 +275,11 @@
 void check(int32_t show)
 {
     AL_Error=balcGetError(device);
-    if (AL_Error!=ALC_NO_ERROR&&show)initprintf("%s(%s)\n",ALC_ErrorString(AL_Error),ALdoing);
+    if (AL_Error!=ALC_NO_ERROR&&show)
+        initprintf("%s(%s)\n",ALC_ErrorString(AL_Error),ALdoing);
     AL_Error=balGetError();
-    if (AL_Error!= AL_NO_ERROR&&show)initprintf("%s(%s)\n", AL_ErrorString(AL_Error),ALdoing);
+    if (AL_Error!= AL_NO_ERROR&&show)
+        initprintf("%s(%s)\n", AL_ErrorString(AL_Error),ALdoing);
 }
 extern ov_callbacks cb;
 
diff -urEBwb /home/terminx/eduke32_src_20090131/source/mdump.cpp ./source/mdump.cpp
--- /home/terminx/eduke32_src_20090131/source/mdump.cpp	2009-01-31 01:15:24.922780000 -0800
+++ ./source/mdump.cpp	2009-02-19 01:39:19.256754000 -0800
@@ -57,7 +57,7 @@
 			/*if (!GetTempPath( _MAX_PATH, szDumpPath ))
 				_tcscpy( szDumpPath, "c:\\temp\\" );
 			*/
-			Bsprintf(szDumpPath,"%s_%u",m_szAppName,timeGetTime());
+			sprintf(szDumpPath,"%s_%u",m_szAppName,timeGetTime());
 			_tcscat( szDumpPath, ".dmp" );
 
 			// ask the user if they want to save a dump file
@@ -79,20 +79,20 @@
 					BOOL bOK = pDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &ExInfo, NULL, NULL );
 					if (bOK)
 					{
-						Bsprintf( szScratch, "Saved dump file to '%s'", szDumpPath );
+						sprintf( szScratch, "Saved dump file to '%s'", szDumpPath );
 						szResult = szScratch;
 						retval = EXCEPTION_EXECUTE_HANDLER;
 					}
 					else
 					{
-						Bsprintf( szScratch, "Failed to save dump file to '%s' (error %d)", szDumpPath, GetLastError() );
+						sprintf( szScratch, "Failed to save dump file to '%s' (error %d)", szDumpPath, GetLastError() );
 						szResult = szScratch;
 					}
 					::CloseHandle(hFile);
 				}
 				else
 				{
-					Bsprintf( szScratch, "Failed to create dump file '%s' (error %d)", szDumpPath, GetLastError() );
+					sprintf( szScratch, "Failed to create dump file '%s' (error %d)", szDumpPath, GetLastError() );
 					szResult = szScratch;
 				}
 			}
diff -urEBwb /home/terminx/eduke32_src_20090131/source/premap.c ./source/premap.c
--- /home/terminx/eduke32_src_20090131/source/premap.c	2009-01-21 14:43:44.298665000 -0800
+++ ./source/premap.c	2009-02-19 08:47:54.128197000 -0800
@@ -37,7 +37,7 @@
 int32_t g_numRealPalettes;
 int16_t SpriteCacheList[MAXTILES][3];
 
-static char precachehightile[2][MAXTILES>>3];
+static uint8_t precachehightile[2][MAXTILES>>3];
 static int32_t  g_precacheCount;
 
 extern char *duke3dgrpstring;
@@ -278,7 +278,7 @@
 }
 
 // FIXME: this function is a piece of shit, needs specific sounds listed
-static int32_t CacheSound(uint32_t num)
+static int32_t G_CacheSound(uint32_t num)
 {
     int16_t fp = -1;
     int32_t   l;
@@ -326,7 +326,7 @@
                 handleevents();
                 Net_GetPackets();
             }
-            CacheSound(i);
+            G_CacheSound(i);
         }
 }
 
@@ -845,7 +845,7 @@
 
 }
 
-static void setupbackdrop(int16_t sky)
+static inline void G_SetupBackdrop(int16_t sky)
 {
     int16_t i;
 
@@ -887,7 +887,7 @@
     pskybits=3;
 }
 
-static void prelevel(char g)
+static inline void prelevel(char g)
 {
     int32_t i, nexti, j, startwall, endwall, lotaglist;
     int32_t lotags[MAXSPRITES];
@@ -922,7 +922,7 @@
                     for (j=0;j<5;j++)
                         tloadtile(sector[i].ceilingpicnum+j, 0);
             }
-            setupbackdrop(sector[i].ceilingpicnum);
+            G_SetupBackdrop(sector[i].ceilingpicnum);
 
             if (sector[i].ceilingpicnum == CLOUDYSKIES && g_numClouds < 127)
                 clouds[g_numClouds++] = i;
@@ -1230,7 +1230,7 @@
 
     g_skillSoundID = -1;
 
-    waitforeverybody();
+    Net_WaitForEverybody();
     ready2send = 0;
 
     if (ud.m_recstat != 2 && ud.last_level >= 0 && ud.multimode > 1 && (ud.coop&GAMETYPE_SCORESHEET))
@@ -1322,22 +1322,6 @@
     X_OnEvent(EVENT_NEWGAME, g_player[screenpeek].ps->i, screenpeek, -1);
 }
 
-int32_t G_GetTeamPalette(int32_t team)
-{
-    switch (team)
-    {
-    case 0:
-        return 3;
-    case 1:
-        return 10;
-    case 2:
-        return 11;
-    case 3:
-        return 12;
-    }
-    return 0;
-}
-
 static void resetpspritevars(char g)
 {
     int16_t i, j, nexti,circ;
@@ -1532,7 +1516,7 @@
     g_moveThingsCount = 0;
 }
 
-void waitforeverybody()
+void Net_WaitForEverybody(void)
 {
     int32_t i;
 
@@ -1948,7 +1932,7 @@
 
     g_restorePalette = 1;
 
-    waitforeverybody();
+    Net_WaitForEverybody();
     mmulti_flushpackets();
 
     G_FadePalette(0,0,0,0);
diff -urEBwb /home/terminx/eduke32_src_20090131/source/savegame.c ./source/savegame.c
--- /home/terminx/eduke32_src_20090131/source/savegame.c	2009-01-09 23:38:50.929875000 -0800
+++ ./source/savegame.c	2009-02-27 23:44:54.535084000 -0800
@@ -201,7 +201,7 @@
         nextpage();
     }
 
-    waitforeverybody();
+    Net_WaitForEverybody();
 
     FX_StopAllSounds();
     S_ClearSoundLocks();
@@ -574,7 +574,7 @@
 
     mmulti_flushpackets();
     clearfifo();
-    waitforeverybody();
+    Net_WaitForEverybody();
 
     G_ResetTimers();
 
@@ -606,7 +606,7 @@
         return -1;
     }
 
-    waitforeverybody();
+    Net_WaitForEverybody();
 
     if (multiflag == 2 && multiwho != myconnectindex)
     {
@@ -878,7 +878,7 @@
 
     ready2send = 1;
 
-    waitforeverybody();
+    Net_WaitForEverybody();
 
     ototalclock = totalclock;
 
diff -urEBwb /home/terminx/eduke32_src_20090131/source/sector.c ./source/sector.c
--- /home/terminx/eduke32_src_20090131/source/sector.c	2009-01-21 14:43:44.298665000 -0800
+++ ./source/sector.c	2009-02-27 23:44:54.535084000 -0800
@@ -3000,10 +3000,7 @@
 
                         if (p->cursectnum > -1)
                         {
-                            p->holoduke_on = i =
-                                                 A_InsertSprite(p->cursectnum,
-                                                                p->posx,
-                                                                p->posy,
+                            p->holoduke_on = i = A_InsertSprite(p->cursectnum,p->posx,p->posy,
                                                                 p->posz+(30<<8),APLAYER,-64,0,0,p->ang,0,0,-1,10);
                             T4 = T5 = 0;
                             SP = snum;
@@ -3142,7 +3139,7 @@
 }
 
 
-void checksectors(int32_t snum)
+void P_CheckSectors(int32_t snum)
 {
     int32_t i = -1,oldz;
     DukePlayer_t *p = g_player[snum].ps;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/sounds.c ./source/sounds.c
--- /home/terminx/eduke32_src_20090131/source/sounds.c	2009-01-31 01:15:24.694794000 -0800
+++ ./source/sounds.c	2009-02-27 23:44:54.535084000 -0800
@@ -52,11 +52,12 @@
 
 void S_SoundStartup(void)
 {
-    int32_t status;
+    int32_t status, err = 0;
 
     // if they chose None lets return
     if (ud.config.FXDevice < 0) return;
 
+RETRY:
     status = FX_Init(ud.config.FXDevice, ud.config.NumVoices, ud.config.NumChannels, ud.config.NumBits, ud.config.MixRate);
     if (status == FX_Ok)
     {
@@ -70,6 +71,20 @@
 
     if (status != FX_Ok)
     {
+        if (!err)
+        {
+#if defined(_WIN32)
+            ud.config.MixRate = 44100;
+#else
+            ud.config.MixRate = 48000;
+#endif
+            ud.config.NumBits = 16;
+            ud.config.NumChannels = 2;
+            ud.config.NumVoices = 32;
+            ud.config.ReverseStereo = 0;
+            err = 1;
+            goto RETRY;
+        }
         Bsprintf(tempbuf, "Sound startup error: %s", FX_ErrorString(FX_Error));
         G_GameExit(tempbuf);
     }
@@ -123,6 +138,15 @@
     }
     else
     {
+        ud.config.MusicDevice = 0;
+
+        status = MUSIC_Init(ud.config.MusicDevice, 0);
+
+        if (status == MUSIC_Ok)
+        {
+            MUSIC_SetVolume(ud.config.MusicVolume);
+        }
+        /*
         initprintf("Couldn't find selected sound card, or, error w/ sound card itself.\n");
 
         S_SoundShutdown();
@@ -134,6 +158,7 @@
         uninitgroupfile();
         //unlink("duke3d.tmp");
         exit(-1);
+        */
     }
 }
 
@@ -160,11 +185,6 @@
     }
 }
 
-void MusicUpdate(void)
-{
-    MUSIC_Update();
-}
-
 void S_MenuSound(void)
 {
     static int32_t SoundNum=0;
@@ -189,7 +209,7 @@
         SELECT_WEAPON
     };
     S_PlaySound(menusnds[SoundNum++]);
-    SoundNum %= 17;
+    SoundNum %= (sizeof(menusnds)/sizeof(menusnds[0]));
 }
 
 void _playmusic(const char *fn)
@@ -398,8 +418,7 @@
         if (*g_sounds[num].ptr == 'C')
             voice = FX_PlayLoopedVOC(g_sounds[num].ptr, start, start + g_sounds[num].soundsiz,
                                      pitch,sndist>>6,sndist>>6,0,g_sounds[num].pr,num);
-        else
-            if (*g_sounds[num].ptr == 'O')
+        else if (*g_sounds[num].ptr == 'O')
                 voice = FX_PlayLoopedOGG(g_sounds[num].ptr, start, start + g_sounds[num].soundsiz,
                                          pitch,sndist>>6,sndist>>6,0,g_sounds[num].pr,num);
             else
@@ -410,8 +429,7 @@
     {
         if (*g_sounds[num].ptr == 'C')
             voice = FX_PlayVOC3D(g_sounds[ num ].ptr,pitch,sndang>>6,sndist>>6, g_sounds[num].pr, num);
-        else
-            if (*g_sounds[num].ptr == 'O')
+        else if (*g_sounds[num].ptr == 'O')
                 voice = FX_PlayOGG3D(g_sounds[ num ].ptr,pitch,sndang>>6,sndist>>6, g_sounds[num].pr, num);
             else
                 voice = FX_PlayWAV3D(g_sounds[ num ].ptr,pitch,sndang>>6,sndist>>6, g_sounds[num].pr, num);
@@ -475,8 +493,7 @@
             voice = FX_PlayLoopedVOC(g_sounds[num].ptr, start, start + g_sounds[num].soundsiz,
                                      pitch,LOUDESTVOLUME,LOUDESTVOLUME,LOUDESTVOLUME,g_sounds[num].pr,num);
         }
-        else
-            if (*g_sounds[num].ptr == 'O')
+        else if (*g_sounds[num].ptr == 'O')
             {
                 start = (int32_t)*(uint16_t *)(g_sounds[num].ptr + 0x14);
                 voice = FX_PlayLoopedOGG(g_sounds[num].ptr, start, start + g_sounds[num].soundsiz,
@@ -493,8 +510,7 @@
     {
         if (*g_sounds[num].ptr == 'C')
             voice = FX_PlayVOC3D(g_sounds[ num ].ptr, pitch,0,255-LOUDESTVOLUME,g_sounds[num].pr, num);
-        else
-            if (*g_sounds[num].ptr == 'O')
+        else if (*g_sounds[num].ptr == 'O')
                 voice = FX_PlayOGG3D(g_sounds[ num ].ptr, pitch,0,255-LOUDESTVOLUME,g_sounds[num].pr, num);
             else
                 voice = FX_PlayWAV3D(g_sounds[ num ].ptr, pitch,0,255-LOUDESTVOLUME,g_sounds[num].pr, num);
@@ -554,7 +570,7 @@
         }
 }
 
-void pan3dsound(void)
+void S_Pan3D(void)
 {
     int32_t sndist, sx, sy, sz, cx, cy, cz;
     int32_t sndang,ca,j,k,i,cs;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/sync.c ./source/sync.c
--- /home/terminx/eduke32_src_20090131/source/sync.c	2009-01-31 01:15:24.599777000 -0800
+++ ./source/sync.c	2009-02-19 08:47:54.128197000 -0800
@@ -319,7 +319,7 @@
 }
 
 
-void  Net_AddSyncInfoToPacket(int32_t *j)
+static inline void Net_AddSyncData(int32_t *j)
 {
     int32_t sb;
     int32_t count = 0;
@@ -334,7 +334,7 @@
     }
 }
 
-void Net_GetSyncInfoFromPacket(char *packbuf, int32_t packbufleng, int32_t *j, int32_t otherconnectindex)
+void Net_GetSyncData(char *packbuf, int32_t packbufleng, int32_t *j, int32_t otherconnectindex)
 {
     int32_t sb, i;
     extern int32_t syncvaltail, syncvaltottail;
diff -urEBwb /home/terminx/eduke32_src_20090131/source/winbits.c ./source/winbits.c
--- /home/terminx/eduke32_src_20090131/source/winbits.c	2009-01-09 01:29:17.505954000 -0800
+++ ./source/winbits.c	2009-03-13 19:55:39.565179000 -0700
@@ -64,7 +64,7 @@
     struct sockaddr_in dest_addr;
     struct hostent *h;
     char *host = "eduke32.sourceforge.net";
-    char *req = "GET http://eduke32.sourceforge.net/VERSION HTTP/1.0\r\n\r\n";
+    char *req = "GET http://eduke32.sourceforge.net/VERSION HTTP/1.0\r\n\r\n\r\n";
     char tempbuf[2048],otherbuf[16],ver[16];
     SOCKET mysock;
 
